{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"DNAbyte","text":"<p>A comprehensive Python toolkit for DNA data storage simulation and analysis</p> <p>DNAbyte provides a complete framework for simulating the entire end-to-end pipeline of DNA-based data storage, from raw files to DNA sequences and back. Whether you're researching novel encoding schemes, testing error correction methods, or analyzing storage durability.</p>"},{"location":"#pipeline-overview","title":"Pipeline Overview","text":"<p>DNAbyte covers the complete DNA storage workflow:</p> <ol> <li>Binarization: Compress and convert input files into binary sequences</li> <li>Encoding: Transform binary data into DNA sequences (including error correction)</li> <li>Synthesis: Simulate DNA synthesis with configurable error models (MESA, assembly-based)</li> <li>Storage: Model degradation over time under various environmental conditions</li> <li>Sequencing: Simulate sequencing technologies (Illumina, Nanopore, IID)</li> <li>Processing: Align and correct sequenced reads</li> <li>Decoding: Recover original binary data with error correction</li> <li>Restoration: Decompress and restore original files</li> </ol> <p></p>"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<ul> <li>Usage Guide - Complete examples and parameter documentation</li> <li>Simulation Guide - Step-by-step simulation tutorials  </li> <li>Core Concepts - Understanding encoding techniques and algorithms</li> <li>API Reference - Comprehensive class and function documentation</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code># Clone the repository\ngit clone https://github.com/Eko-Refugium/DNAbyte.git\ncd DNAbyte\n\n# Install dependencies\npip install -r requirements.txt\n\n# Install in development mode\npip install -e .\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from dnabyte.params import Params\nfrom dnabyte.data_classes.base import Data\nfrom dnabyte.binarize import Binarize\nfrom dnabyte.encode import Encode\n\n# Set up parameters\nparams = Params(\n    file_paths=['data.txt'],\n    encoding_method='max_density',\n    binarization_method='compressed',\n    outer_error_correction='reedsolomon',\n    reed_solo_percentage=0.8\n)\n\n# Run the pipeline\ndata = Data(file_paths=params.file_paths)\nbinarizer = Binarize(params)\nencoder = Encode(params)\n\nbinary_code = binarizer.binarize(data)\nnucleobase_code, info = encoder.encode(binary_code)\n</code></pre>"},{"location":"#citation","title":"Citation","text":"<p>If you use DNAbyte in your research, please cite:</p> <pre><code>@software{dnabyte2025,\n  title = {DNAbyte: A Framework for End-to-end DNA Data Storage Simulation},\n  author = {Kaya Wernhart and Fabian Schroeder},\n  year = {2025},\n  url = {https://github.com/Eko-Refugium/DNAbyte}\n}\n</code></pre>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>Eko Refugium is part of the MI-DNA DISC consortium (www.midnadisc.eu).</p> <p>MI-DNA DISC was funded by the EU Commission in the framework of the Horizon Europe \u2013 EIC Pathfinder Challenges programme.</p> <p>Grant Agreement: 101115215</p> <p></p>"},{"location":"#license","title":"License","text":"<p>See LICENSE for details.</p>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#data-classes","title":"Data Classes","text":"<p>DNAbyte uses different data structures to represent information at various stages of the DNA storage pipeline.</p>"},{"location":"reference/#data-base-class","title":"Data (Base Class)","text":"<p>Data is the base class for all data types in the DNAbyte pipeline.</p> <p>It can be instantiated   - with a list of absolute paths to files or, alternatively  - with a path to a folder using the alternative constructor from_folder.</p> <p>:param file_paths: A list of absolute paths to files.</p> Source code in <code>dnabyte/data_classes/base.py</code> <pre><code>class Data:\n    \"\"\"\n    Data is the base class for all data types in the DNAbyte pipeline.\n\n    It can be instantiated \n     - with a list of absolute paths to files or, alternatively\n     - with a path to a folder using the alternative constructor from_folder.\n\n    :param file_paths: A list of absolute paths to files.    \n    \"\"\"\n\n    # Class constant for maximum file size (1MB in bytes)\n    MAX_FILE_SIZE = 1024 * 1024  # 1MB\n\n    def __init__(self, file_paths):\n        \"\"\"\n        Initialize Data object with file paths.\n\n        :param file_paths: List of absolute paths to files\n        :raises TypeError: If file_paths is not a list\n        :raises ValueError: If file_paths is empty, contains invalid paths, or files exceed size limit\n        \"\"\"\n        # Validate input type\n        if not isinstance(file_paths, list):\n            raise TypeError(f\"file_paths must be a list, got {type(file_paths).__name__}\")\n\n        # Check if list is empty\n        if len(file_paths) == 0:\n            raise ValueError(\"file_paths cannot be empty\")\n\n        # Validate each file path\n        for file_path in file_paths:\n            if not isinstance(file_path, str):\n                raise TypeError(f\"All file paths must be strings, got {type(file_path).__name__}\")\n            if not os.path.isfile(file_path):\n                raise ValueError(f\"File path {file_path} does not point to an existing file.\")\n\n            # Check file size\n            file_size = os.path.getsize(file_path)\n            if file_size &gt; self.MAX_FILE_SIZE:\n                raise ValueError(f\"File {file_path} exceeds maximum size limit of \"\n                               f\"{self.MAX_FILE_SIZE / (1024*1024):.1f}MB. \"\n                               f\"File size: {file_size / (1024*1024):.2f}MB\")\n\n        self.file_paths = file_paths\n        self.size = self.calculate_total_bytes()\n\n    @classmethod\n    def from_folder(cls, folder_path):\n        \"\"\"\n        Create Data object from all files in a folder.\n\n        :param folder_path: Path to directory containing files\n        :return: Data object with all files in the folder\n        :raises TypeError: If folder_path is not a string\n        :raises ValueError: If folder path doesn't exist or contains no files\n        \"\"\"\n        if not isinstance(folder_path, str):\n            raise TypeError(f\"folder_path must be a string, got {type(folder_path).__name__}\")\n\n        if not os.path.isdir(folder_path):\n            raise ValueError(f\"Folder path {folder_path} does not point to an existing directory.\")\n\n        # Get only files, not directories\n        all_items = os.listdir(folder_path)\n        file_paths = [os.path.join(folder_path, item) for item in all_items \n                     if os.path.isfile(os.path.join(folder_path, item))]\n\n        if not file_paths:\n            raise ValueError(f\"No files found in directory {folder_path}\")\n\n        return cls(file_paths)\n\n    def calculate_total_bytes(self):\n        \"\"\"\n        Calculate total size of all files in bytes.\n\n        :return: Total size in bytes\n        \"\"\"\n        total_bytes = 0\n        for file_path in self.file_paths:\n            total_bytes += os.path.getsize(file_path)\n        return total_bytes\n\n    def __str__(self):\n        \"\"\"\n        String representation of the Data object.\n\n        :return: Formatted string with object information\n        \"\"\"\n        output = f\"Type: {type(self).__name__}\\n\"\n        output += f\"Total size: {self.size} bytes ({self.size / (1024*1024):.2f} MB)\\n\"\n        output += f\"Number of files: {len(self.file_paths)}\\n\"\n        output += f\"File paths: {self.file_paths}\\n\"\n        return output\n</code></pre>"},{"location":"reference/#dnabyte.data_classes.base.Data.__init__","title":"<code>__init__(file_paths)</code>","text":"<p>Initialize Data object with file paths.</p> <p>:param file_paths: List of absolute paths to files :raises TypeError: If file_paths is not a list :raises ValueError: If file_paths is empty, contains invalid paths, or files exceed size limit</p> Source code in <code>dnabyte/data_classes/base.py</code> <pre><code>def __init__(self, file_paths):\n    \"\"\"\n    Initialize Data object with file paths.\n\n    :param file_paths: List of absolute paths to files\n    :raises TypeError: If file_paths is not a list\n    :raises ValueError: If file_paths is empty, contains invalid paths, or files exceed size limit\n    \"\"\"\n    # Validate input type\n    if not isinstance(file_paths, list):\n        raise TypeError(f\"file_paths must be a list, got {type(file_paths).__name__}\")\n\n    # Check if list is empty\n    if len(file_paths) == 0:\n        raise ValueError(\"file_paths cannot be empty\")\n\n    # Validate each file path\n    for file_path in file_paths:\n        if not isinstance(file_path, str):\n            raise TypeError(f\"All file paths must be strings, got {type(file_path).__name__}\")\n        if not os.path.isfile(file_path):\n            raise ValueError(f\"File path {file_path} does not point to an existing file.\")\n\n        # Check file size\n        file_size = os.path.getsize(file_path)\n        if file_size &gt; self.MAX_FILE_SIZE:\n            raise ValueError(f\"File {file_path} exceeds maximum size limit of \"\n                           f\"{self.MAX_FILE_SIZE / (1024*1024):.1f}MB. \"\n                           f\"File size: {file_size / (1024*1024):.2f}MB\")\n\n    self.file_paths = file_paths\n    self.size = self.calculate_total_bytes()\n</code></pre>"},{"location":"reference/#dnabyte.data_classes.base.Data.__str__","title":"<code>__str__()</code>","text":"<p>String representation of the Data object.</p> <p>:return: Formatted string with object information</p> Source code in <code>dnabyte/data_classes/base.py</code> <pre><code>def __str__(self):\n    \"\"\"\n    String representation of the Data object.\n\n    :return: Formatted string with object information\n    \"\"\"\n    output = f\"Type: {type(self).__name__}\\n\"\n    output += f\"Total size: {self.size} bytes ({self.size / (1024*1024):.2f} MB)\\n\"\n    output += f\"Number of files: {len(self.file_paths)}\\n\"\n    output += f\"File paths: {self.file_paths}\\n\"\n    return output\n</code></pre>"},{"location":"reference/#dnabyte.data_classes.base.Data.calculate_total_bytes","title":"<code>calculate_total_bytes()</code>","text":"<p>Calculate total size of all files in bytes.</p> <p>:return: Total size in bytes</p> Source code in <code>dnabyte/data_classes/base.py</code> <pre><code>def calculate_total_bytes(self):\n    \"\"\"\n    Calculate total size of all files in bytes.\n\n    :return: Total size in bytes\n    \"\"\"\n    total_bytes = 0\n    for file_path in self.file_paths:\n        total_bytes += os.path.getsize(file_path)\n    return total_bytes\n</code></pre>"},{"location":"reference/#dnabyte.data_classes.base.Data.from_folder","title":"<code>from_folder(folder_path)</code>  <code>classmethod</code>","text":"<p>Create Data object from all files in a folder.</p> <p>:param folder_path: Path to directory containing files :return: Data object with all files in the folder :raises TypeError: If folder_path is not a string :raises ValueError: If folder path doesn't exist or contains no files</p> Source code in <code>dnabyte/data_classes/base.py</code> <pre><code>@classmethod\ndef from_folder(cls, folder_path):\n    \"\"\"\n    Create Data object from all files in a folder.\n\n    :param folder_path: Path to directory containing files\n    :return: Data object with all files in the folder\n    :raises TypeError: If folder_path is not a string\n    :raises ValueError: If folder path doesn't exist or contains no files\n    \"\"\"\n    if not isinstance(folder_path, str):\n        raise TypeError(f\"folder_path must be a string, got {type(folder_path).__name__}\")\n\n    if not os.path.isdir(folder_path):\n        raise ValueError(f\"Folder path {folder_path} does not point to an existing directory.\")\n\n    # Get only files, not directories\n    all_items = os.listdir(folder_path)\n    file_paths = [os.path.join(folder_path, item) for item in all_items \n                 if os.path.isfile(os.path.join(folder_path, item))]\n\n    if not file_paths:\n        raise ValueError(f\"No files found in directory {folder_path}\")\n\n    return cls(file_paths)\n</code></pre>"},{"location":"reference/#binarycode","title":"BinaryCode","text":"<p>               Bases: <code>Data</code></p> <p>Represents binary data as a sequence of '0' and '1' characters.</p> <p>BinaryCode stores and manipulates binary data streams created from file  binarization processes. It provides validation, indexing, and iteration  capabilities for working with binary representations of original data.</p> <p>Extends the Data base class to maintain compatibility with the DNAbyte  pipeline while providing binary-specific functionality.</p> Can be created either <ul> <li>from file data using a Binarize method, or</li> <li>directly by providing a binary string.</li> </ul> <p>:param bitstream: A string of binary data (only '0' and '1' characters). :param file_paths: Optional list of original file paths (for inheritance compatibility). :param size: Optional original file size in bytes. :raises TypeError: If bitstream is not a string. :raises ValueError: If bitstream is empty or contains non-binary characters.</p> Example <p>binary = BinaryCode(\"10110010\", file_paths=[\"/path/to/file.txt\"]) print(len(binary))  # 8 print(binary[0])    # '1'</p> Source code in <code>dnabyte/data_classes/binarycode.py</code> <pre><code>class BinaryCode(Data):\n    \"\"\"\n    Represents binary data as a sequence of '0' and '1' characters.\n\n    BinaryCode stores and manipulates binary data streams created from file \n    binarization processes. It provides validation, indexing, and iteration \n    capabilities for working with binary representations of original data.\n\n    Extends the Data base class to maintain compatibility with the DNAbyte \n    pipeline while providing binary-specific functionality.\n\n    Can be created either:\n        - from file data using a Binarize method, or\n        - directly by providing a binary string.\n\n    :param bitstream: A string of binary data (only '0' and '1' characters).\n    :param file_paths: Optional list of original file paths (for inheritance compatibility).\n    :param size: Optional original file size in bytes.\n    :raises TypeError: If bitstream is not a string.\n    :raises ValueError: If bitstream is empty or contains non-binary characters.\n\n    Example:\n        &gt;&gt;&gt; binary = BinaryCode(\"10110010\", file_paths=[\"/path/to/file.txt\"])\n        &gt;&gt;&gt; print(len(binary))  # 8\n        &gt;&gt;&gt; print(binary[0])    # '1'\n    \"\"\"\n\n    def __init__(self, data, file_paths=None, size=None):\n        \"\"\"\n        Creates a BinaryCode object from a bitstream.\n\n        :param bitstream: A string of binary data.\n        :param file_paths: Optional list of original file paths.\n        :param size: Optional original file size in bytes.\n        \"\"\"\n\n        #print(data, 'data in binarycode init')\n        # Validate the bitstream before setting any attributes\n        self._validate_bitstream(data)\n\n        # Set binary-specific attributes\n        self.data = data\n        self.length = len(data)\n\n        # Handle inheritance - set attributes for parent class compatibility\n        self.file_paths = file_paths or []\n        self.size = size  # Keep track of original file size\n\n    def _validate_bitstream(self, data):\n        \"\"\"\n        Validates that the input is a proper bitstream.\n\n        :param bitstream: The data to validate\n        :raises TypeError: If bitstream is not a string\n        :raises ValueError: If bitstream is empty or contains invalid characters\n        \"\"\"\n        # Check if data is a string\n        if not isinstance(data, str):\n            raise TypeError(\n                f\"Bitstream must be a string, got {type(data).__name__}\"\n            )\n\n        # Check if data is empty\n        if len(data) == 0:\n            raise ValueError(\"Bitstream cannot be empty\")\n\n        # Check if all characters are either '0' or '1'\n        invalid_chars = set(char for char in data if char not in \"01\")\n        if invalid_chars:\n            raise ValueError(\n                f\"Bitstream contains invalid characters: {invalid_chars}. \"\n                f\"Only '0' and '1' are allowed.\"\n            )\n\n    def compare_binary_strings(self, bin_str1, bin_str2):\n        \"\"\"\n        Helper function for compare(). Compare two binary strings and return the indices of the differing bits.\n        \"\"\"\n        differences = []\n        min_length = min(len(bin_str1), len(bin_str2))\n\n        for i in range(min_length):\n            if bin_str1[i] != bin_str2[i]:\n                differences.append(i)\n\n        return differences\n\n\n    def compare(self, data_dec, data_bin, logger=None):\n        \"\"\"\n        Compare decoded data with raw data and return the result of the comparison.\n\n        Args:\n            data_dec (BinaryCode): The decoded data object.\n            data_bin (BinaryCode): The raw data object.\n\n        Returns:\n            str: A message indicating whether the data was successfully decoded or not.\n        \"\"\"\n        res = self.compare_binary_strings(data_dec.data, data_bin.data)\n\n        if res == [] and len(data_dec.data) == len(data_bin.data):\n            return 'SUCCESS', res\n        else:\n            return 'ERROR', res\n\n    def random(n):\n        \"\"\"\n        Generates a random BinaryCode object with a specified length.\n\n        :param n: Length of the binary string to generate.\n        :return: BinaryCode object with random binary data.\n        \"\"\"\n        bitstream = ''.join(random.choice('01') for _ in range(n))\n        return BinaryCode(bitstream)\n\n    def __str__(self):\n        output = f\"Type: {type(self).__name__}\\n\"\n        output += f\"Length: {self.length} bits\\n\"\n        if self.size is not None:\n            output += f\"Size: {self.size} bytes\\n\"\n        output += f\"Data: {self.data[0:50]}...\\n\"\n        return output\n\n    def __repr__(self):\n        \"\"\"\n        Developer-friendly representation of the BinaryCode object.\n\n        :return: Unambiguous string representation\n        \"\"\"\n        # Truncate data if too long for readable repr\n        if len(self.data) &gt; 20:\n            data_repr = f\"{self.data[:20]}...\"\n        else:\n            data_repr = self.data\n\n        return f\"BinaryCode(bitstream='{data_repr}', length={self.length})\"\n\n    def __len__(self):\n        \"\"\"Return the number of bits in the bitstream.\"\"\"\n        return len(self.data)\n\n    def __getitem__(self, index):\n        \"\"\"Allow indexing to get individual bits or slices.\"\"\"\n        return self.data[index]\n\n    def __iter__(self):\n        \"\"\"Allow iteration over individual bits.\"\"\"\n        return iter(self.data)\n</code></pre>"},{"location":"reference/#dnabyte.data_classes.binarycode.BinaryCode.__getitem__","title":"<code>__getitem__(index)</code>","text":"<p>Allow indexing to get individual bits or slices.</p> Source code in <code>dnabyte/data_classes/binarycode.py</code> <pre><code>def __getitem__(self, index):\n    \"\"\"Allow indexing to get individual bits or slices.\"\"\"\n    return self.data[index]\n</code></pre>"},{"location":"reference/#dnabyte.data_classes.binarycode.BinaryCode.__init__","title":"<code>__init__(data, file_paths=None, size=None)</code>","text":"<p>Creates a BinaryCode object from a bitstream.</p> <p>:param bitstream: A string of binary data. :param file_paths: Optional list of original file paths. :param size: Optional original file size in bytes.</p> Source code in <code>dnabyte/data_classes/binarycode.py</code> <pre><code>def __init__(self, data, file_paths=None, size=None):\n    \"\"\"\n    Creates a BinaryCode object from a bitstream.\n\n    :param bitstream: A string of binary data.\n    :param file_paths: Optional list of original file paths.\n    :param size: Optional original file size in bytes.\n    \"\"\"\n\n    #print(data, 'data in binarycode init')\n    # Validate the bitstream before setting any attributes\n    self._validate_bitstream(data)\n\n    # Set binary-specific attributes\n    self.data = data\n    self.length = len(data)\n\n    # Handle inheritance - set attributes for parent class compatibility\n    self.file_paths = file_paths or []\n    self.size = size  # Keep track of original file size\n</code></pre>"},{"location":"reference/#dnabyte.data_classes.binarycode.BinaryCode.__iter__","title":"<code>__iter__()</code>","text":"<p>Allow iteration over individual bits.</p> Source code in <code>dnabyte/data_classes/binarycode.py</code> <pre><code>def __iter__(self):\n    \"\"\"Allow iteration over individual bits.\"\"\"\n    return iter(self.data)\n</code></pre>"},{"location":"reference/#dnabyte.data_classes.binarycode.BinaryCode.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of bits in the bitstream.</p> Source code in <code>dnabyte/data_classes/binarycode.py</code> <pre><code>def __len__(self):\n    \"\"\"Return the number of bits in the bitstream.\"\"\"\n    return len(self.data)\n</code></pre>"},{"location":"reference/#dnabyte.data_classes.binarycode.BinaryCode.__repr__","title":"<code>__repr__()</code>","text":"<p>Developer-friendly representation of the BinaryCode object.</p> <p>:return: Unambiguous string representation</p> Source code in <code>dnabyte/data_classes/binarycode.py</code> <pre><code>def __repr__(self):\n    \"\"\"\n    Developer-friendly representation of the BinaryCode object.\n\n    :return: Unambiguous string representation\n    \"\"\"\n    # Truncate data if too long for readable repr\n    if len(self.data) &gt; 20:\n        data_repr = f\"{self.data[:20]}...\"\n    else:\n        data_repr = self.data\n\n    return f\"BinaryCode(bitstream='{data_repr}', length={self.length})\"\n</code></pre>"},{"location":"reference/#dnabyte.data_classes.binarycode.BinaryCode.compare","title":"<code>compare(data_dec, data_bin, logger=None)</code>","text":"<p>Compare decoded data with raw data and return the result of the comparison.</p> <p>Parameters:</p> Name Type Description Default <code>data_dec</code> <code>BinaryCode</code> <p>The decoded data object.</p> required <code>data_bin</code> <code>BinaryCode</code> <p>The raw data object.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>A message indicating whether the data was successfully decoded or not.</p> Source code in <code>dnabyte/data_classes/binarycode.py</code> <pre><code>def compare(self, data_dec, data_bin, logger=None):\n    \"\"\"\n    Compare decoded data with raw data and return the result of the comparison.\n\n    Args:\n        data_dec (BinaryCode): The decoded data object.\n        data_bin (BinaryCode): The raw data object.\n\n    Returns:\n        str: A message indicating whether the data was successfully decoded or not.\n    \"\"\"\n    res = self.compare_binary_strings(data_dec.data, data_bin.data)\n\n    if res == [] and len(data_dec.data) == len(data_bin.data):\n        return 'SUCCESS', res\n    else:\n        return 'ERROR', res\n</code></pre>"},{"location":"reference/#dnabyte.data_classes.binarycode.BinaryCode.compare_binary_strings","title":"<code>compare_binary_strings(bin_str1, bin_str2)</code>","text":"<p>Helper function for compare(). Compare two binary strings and return the indices of the differing bits.</p> Source code in <code>dnabyte/data_classes/binarycode.py</code> <pre><code>def compare_binary_strings(self, bin_str1, bin_str2):\n    \"\"\"\n    Helper function for compare(). Compare two binary strings and return the indices of the differing bits.\n    \"\"\"\n    differences = []\n    min_length = min(len(bin_str1), len(bin_str2))\n\n    for i in range(min_length):\n        if bin_str1[i] != bin_str2[i]:\n            differences.append(i)\n\n    return differences\n</code></pre>"},{"location":"reference/#dnabyte.data_classes.binarycode.BinaryCode.random","title":"<code>random(n)</code>","text":"<p>Generates a random BinaryCode object with a specified length.</p> <p>:param n: Length of the binary string to generate. :return: BinaryCode object with random binary data.</p> Source code in <code>dnabyte/data_classes/binarycode.py</code> <pre><code>def random(n):\n    \"\"\"\n    Generates a random BinaryCode object with a specified length.\n\n    :param n: Length of the binary string to generate.\n    :return: BinaryCode object with random binary data.\n    \"\"\"\n    bitstream = ''.join(random.choice('01') for _ in range(n))\n    return BinaryCode(bitstream)\n</code></pre>"},{"location":"reference/#nucleobasecode","title":"NucleobaseCode","text":"<p>               Bases: <code>Data</code></p> <p>NucleobaseCode is a subclass of Data. Its main attribute is the data object, which consists of a multi-leveled list. At the highest level, data consists of a list of codewords, there is one list for every codeword in the data object. At the lowest level there are lists of motifs or nucleotides, that are to be hybridised in a single pool. The list structure represents the hierarchical structure of the pooling process.</p> It can be instantiated either by <ul> <li>by an encoder producing the encoded data structure or</li> <li>directly providing the encoded data structure as a parameter.</li> </ul> <p>:param data: The encoded data structure (multi-level list of codewords). :param file_paths: Optional list of original file paths. :param size: Optional size information from original data. :raises TypeError: If data is not a list. :raises ValueError: If data is empty or has invalid structure.</p> Source code in <code>dnabyte/data_classes/nucleobasecode.py</code> <pre><code>class NucleobaseCode(Data):\n    \"\"\"\n    NucleobaseCode is a subclass of Data. Its main attribute is the data object, which consists of a multi-leveled list. At the highest level, data consists of a list of codewords, there is one list for every codeword in the data object.\n    At the lowest level there are lists of motifs or nucleotides, that are to be hybridised in a single pool. The list\n    structure represents the hierarchical structure of the pooling process.\n\n    It can be instantiated either by:\n        - by an encoder producing the encoded data structure or\n        - directly providing the encoded data structure as a parameter.\n\n    :param data: The encoded data structure (multi-level list of codewords).\n    :param file_paths: Optional list of original file paths.\n    :param size: Optional size information from original data.\n    :raises TypeError: If data is not a list.\n    :raises ValueError: If data is empty or has invalid structure.\n    \"\"\"\n\n    def __init__(self, data):\n        \"\"\"\n        Creates a NucleobaseCode object from encoded data structure.\n\n        :param data: Multi-level list structure representing encoded codewords.\n        \"\"\"\n        # Validate the encoded data before setting any attributes\n        self._validate_data(data)\n        self.data = data\n        self.num_codewords = len(data) if data else 0\n\n        # Calculate additional metrics\n        self.max_depth = self._calculate_max_depth()\n\n    def _validate_data(self, data):\n        \"\"\"\n        Validates that the input is a proper encoded data structure.\n\n        :param data: The data to validate\n        :raises TypeError: If data is not a list\n        :raises ValueError: If data is empty or has invalid structure\n        \"\"\"\n        # Check if data is a list\n        if not isinstance(data, list):\n            raise TypeError(\n                f\"Encoded data must be a list, got {type(data).__name__}\"\n            )\n\n        # Check if data is empty\n        if len(data) == 0:\n            raise ValueError(\"Encoded data cannot be empty\")\n\n        # TODO: Check structure of the codewords\n        # TODO: Check whether each codeword contains only valid nucleotides\n        # self._validate_codeword_structure(data)\n\n\n    # TODO: calculate_max_depth delivers incorrect results in some tests\n    def _calculate_max_depth(self):\n        \"\"\"\n        Calculates the maximum depth of the nested structure.\n\n        :return: Maximum nesting depth\n        \"\"\"\n        if not self.data:\n            return 0\n\n        max_depth = 0\n        for codeword in self.data:\n            depth = self._get_depth_recursive(codeword)\n            max_depth = max(max_depth, depth)\n        return max_depth\n\n    def _get_depth_recursive(self, structure):\n        \"\"\"\n        Recursively calculates depth of nested structure.\n\n        :param structure: The structure to measure depth of\n        :return: Depth of structure\n        \"\"\"\n        if isinstance(structure, list):\n            if not structure:\n                return 1\n            return 1 + max(self._get_depth_recursive(item) for item in structure)\n        else:\n            return 0  # Nucleotide has no depth\n\n    def get_codeword(self, index):\n        \"\"\"\n        Get a specific codeword by index.\n\n        :param index: Index of the codeword\n        :return: The codeword at the specified index\n        :raises IndexError: If index is out of range\n        \"\"\"\n        if not 0 &lt;= index &lt; len(self.data):\n            raise IndexError(\n                f\"Codeword index {index} out of range (0-{len(self.data)-1})\"\n            )\n        return self.data[index]\n\n    def validate(self):\n        \"\"\"\n        Re-validates the current encoded data structure.\n\n        :return: True if valid\n        :raises: Various exceptions if invalid\n        \"\"\"\n        self._validate_data(self.data)\n        return True\n\n    def random(type='synthesis', library = None, n=1000, m=250):\n        \"\"\"\n        Generates a random NucleobaseCode object with a specified number of codewords.\n\n        :param type: Type of nucleobase code (e.g., 'DNA', 'RNA')\n        :param n: Number of codewords to generate\n        :return: NucleobaseCode object with random data\n        \"\"\"\n        data = []\n\n        if type == 'synthesis':\n\n            for _ in range(n):\n                codeword = ''.join(random.choice(['A', 'T', 'C', 'G']) for _ in range(m))\n                data.append(codeword)\n\n        elif type == 'nested_assembly':\n            if library is None:\n                raise ValueError(\"Library must be provided for assembly type\")\n\n            else:\n                library = Library(structure='linear_assembly', filename='./tests/testlibraries/20bp_Lib.csv')\n\n                # Helper function to create nested list of random depth\n                def create_nested_structure(current_depth, max_depth):\n                    \"\"\"Recursively create nested list structure with random depth.\"\"\"\n                    # If we've reached max depth or randomly decide to stop, return a leaf element\n                    if current_depth &gt;= max_depth or (current_depth &gt; 0 and random.random() &lt; 0.3):\n                        return random.choice(library.library)\n\n                    # Create a list with 1-3 children\n                    num_children = random.randint(1, 3)\n                    return [create_nested_structure(current_depth + 1, max_depth) for _ in range(num_children)]\n\n                # Generate n codewords, each with random nested structure (depth 1-5)\n                for _ in range(n):\n                    max_depth = random.randint(1, 5)\n                    codeword = create_nested_structure(0, max_depth)\n                    data.append(codeword)\n\n\n        elif type == 'linear_assembly':\n            if library is None:\n                raise ValueError(\"Library must be provided for assembly type\")\n\n            else:\n                library = Library(structure='linear_assembly', filename='./tests/testlibraries/20bp_Lib.csv')\n\n                # Generate n codewords, each with m library elements\n                for _ in range(n):\n                    codeword = random.choices(library.library, k=m)\n                    data.append(codeword)\n\n        else:\n            raise ValueError(f\"Invalid synthesis type: {type}\")\n\n        return NucleobaseCode(data)\n\n\n    def __str__(self):\n        output = f\"Type: {type(self).__name__}\\n\"\n        output += f\"Number of codewords: {self.num_codewords}\\n\"\n        output += f\"Max depth: {self.max_depth}\\n\"\n\n        # Add file paths if they exist\n        if hasattr(self, \"file_paths\") and self.file_paths:\n            output += f\"File paths: {self.file_paths}\\n\"\n\n        if hasattr(self, \"size\") and self.size:\n            output += f\"Original size: {self.size} bytes\\n\"\n\n        output += f\"DATA: {str(self.data)[:100]}...\\n\"\n        return output\n\n    def __len__(self):\n        \"\"\"Return the number of codewords.\"\"\"\n        return len(self.data)\n\n    def __getitem__(self, index):\n        \"\"\"Allow indexing to get codewords.\"\"\"\n        return self.get_codeword(index)\n</code></pre>"},{"location":"reference/#dnabyte.data_classes.nucleobasecode.NucleobaseCode.__getitem__","title":"<code>__getitem__(index)</code>","text":"<p>Allow indexing to get codewords.</p> Source code in <code>dnabyte/data_classes/nucleobasecode.py</code> <pre><code>def __getitem__(self, index):\n    \"\"\"Allow indexing to get codewords.\"\"\"\n    return self.get_codeword(index)\n</code></pre>"},{"location":"reference/#dnabyte.data_classes.nucleobasecode.NucleobaseCode.__init__","title":"<code>__init__(data)</code>","text":"<p>Creates a NucleobaseCode object from encoded data structure.</p> <p>:param data: Multi-level list structure representing encoded codewords.</p> Source code in <code>dnabyte/data_classes/nucleobasecode.py</code> <pre><code>def __init__(self, data):\n    \"\"\"\n    Creates a NucleobaseCode object from encoded data structure.\n\n    :param data: Multi-level list structure representing encoded codewords.\n    \"\"\"\n    # Validate the encoded data before setting any attributes\n    self._validate_data(data)\n    self.data = data\n    self.num_codewords = len(data) if data else 0\n\n    # Calculate additional metrics\n    self.max_depth = self._calculate_max_depth()\n</code></pre>"},{"location":"reference/#dnabyte.data_classes.nucleobasecode.NucleobaseCode.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of codewords.</p> Source code in <code>dnabyte/data_classes/nucleobasecode.py</code> <pre><code>def __len__(self):\n    \"\"\"Return the number of codewords.\"\"\"\n    return len(self.data)\n</code></pre>"},{"location":"reference/#dnabyte.data_classes.nucleobasecode.NucleobaseCode.get_codeword","title":"<code>get_codeword(index)</code>","text":"<p>Get a specific codeword by index.</p> <p>:param index: Index of the codeword :return: The codeword at the specified index :raises IndexError: If index is out of range</p> Source code in <code>dnabyte/data_classes/nucleobasecode.py</code> <pre><code>def get_codeword(self, index):\n    \"\"\"\n    Get a specific codeword by index.\n\n    :param index: Index of the codeword\n    :return: The codeword at the specified index\n    :raises IndexError: If index is out of range\n    \"\"\"\n    if not 0 &lt;= index &lt; len(self.data):\n        raise IndexError(\n            f\"Codeword index {index} out of range (0-{len(self.data)-1})\"\n        )\n    return self.data[index]\n</code></pre>"},{"location":"reference/#dnabyte.data_classes.nucleobasecode.NucleobaseCode.random","title":"<code>random(type='synthesis', library=None, n=1000, m=250)</code>","text":"<p>Generates a random NucleobaseCode object with a specified number of codewords.</p> <p>:param type: Type of nucleobase code (e.g., 'DNA', 'RNA') :param n: Number of codewords to generate :return: NucleobaseCode object with random data</p> Source code in <code>dnabyte/data_classes/nucleobasecode.py</code> <pre><code>def random(type='synthesis', library = None, n=1000, m=250):\n    \"\"\"\n    Generates a random NucleobaseCode object with a specified number of codewords.\n\n    :param type: Type of nucleobase code (e.g., 'DNA', 'RNA')\n    :param n: Number of codewords to generate\n    :return: NucleobaseCode object with random data\n    \"\"\"\n    data = []\n\n    if type == 'synthesis':\n\n        for _ in range(n):\n            codeword = ''.join(random.choice(['A', 'T', 'C', 'G']) for _ in range(m))\n            data.append(codeword)\n\n    elif type == 'nested_assembly':\n        if library is None:\n            raise ValueError(\"Library must be provided for assembly type\")\n\n        else:\n            library = Library(structure='linear_assembly', filename='./tests/testlibraries/20bp_Lib.csv')\n\n            # Helper function to create nested list of random depth\n            def create_nested_structure(current_depth, max_depth):\n                \"\"\"Recursively create nested list structure with random depth.\"\"\"\n                # If we've reached max depth or randomly decide to stop, return a leaf element\n                if current_depth &gt;= max_depth or (current_depth &gt; 0 and random.random() &lt; 0.3):\n                    return random.choice(library.library)\n\n                # Create a list with 1-3 children\n                num_children = random.randint(1, 3)\n                return [create_nested_structure(current_depth + 1, max_depth) for _ in range(num_children)]\n\n            # Generate n codewords, each with random nested structure (depth 1-5)\n            for _ in range(n):\n                max_depth = random.randint(1, 5)\n                codeword = create_nested_structure(0, max_depth)\n                data.append(codeword)\n\n\n    elif type == 'linear_assembly':\n        if library is None:\n            raise ValueError(\"Library must be provided for assembly type\")\n\n        else:\n            library = Library(structure='linear_assembly', filename='./tests/testlibraries/20bp_Lib.csv')\n\n            # Generate n codewords, each with m library elements\n            for _ in range(n):\n                codeword = random.choices(library.library, k=m)\n                data.append(codeword)\n\n    else:\n        raise ValueError(f\"Invalid synthesis type: {type}\")\n\n    return NucleobaseCode(data)\n</code></pre>"},{"location":"reference/#dnabyte.data_classes.nucleobasecode.NucleobaseCode.validate","title":"<code>validate()</code>","text":"<p>Re-validates the current encoded data structure.</p> <p>:return: True if valid :raises: Various exceptions if invalid</p> Source code in <code>dnabyte/data_classes/nucleobasecode.py</code> <pre><code>def validate(self):\n    \"\"\"\n    Re-validates the current encoded data structure.\n\n    :return: True if valid\n    :raises: Various exceptions if invalid\n    \"\"\"\n    self._validate_data(self.data)\n    return True\n</code></pre>"},{"location":"reference/#insilicodna","title":"InSilicoDNA","text":"<p>               Bases: <code>Data</code></p> <p>Represents synthesized DNA sequences as oligonucleotide strings.</p> <p>InSilicoDNA contains a collection of DNA sequences (strings of 'A', 'C', 'G', 'T') that represent synthesized DNA. This class is used for DNA synthesis simulation and applying error channels like storage simulation and PCR amplification.</p> <p>Inherits from Data to maintain compatibility with the DNAbyte pipeline.</p> It can be instantiated either <ul> <li>by a synthesis simulator producing the synthesised DNA sequences, or</li> <li>directly providing the list of DNA sequences as a parameter.</li> </ul> <p>:param data: List of DNA sequences (strings of nucleotides). :raises TypeError: If data is not a list. :raises ValueError: If data is empty or contains invalid DNA sequences.</p> Source code in <code>dnabyte/data_classes/insilicodna.py</code> <pre><code>class InSilicoDNA(Data):\n    \"\"\"\n    Represents synthesized DNA sequences as oligonucleotide strings.\n\n    InSilicoDNA contains a collection of DNA sequences (strings of 'A', 'C', 'G', 'T')\n    that represent synthesized DNA. This class is used for DNA synthesis simulation\n    and applying error channels like storage simulation and PCR amplification.\n\n    Inherits from Data to maintain compatibility with the DNAbyte pipeline.\n\n    It can be instantiated either:\n        - by a synthesis simulator producing the synthesised DNA sequences, or\n        - directly providing the list of DNA sequences as a parameter.\n\n    :param data: List of DNA sequences (strings of nucleotides).\n    :raises TypeError: If data is not a list.\n    :raises ValueError: If data is empty or contains invalid DNA sequences.\n    \"\"\"\n\n    def __init__(self, data):\n        \"\"\"\n        Creates a DNA object from DNA sequences.\n\n        :param data: List of DNA sequences (strings).\n        \"\"\"\n\n        # Initialize directly from DNA sequences\n        self._validate_dna_data(data)\n        self.data = data\n        self.file_paths = []\n        self.size = None\n\n        # Calculate metrics\n        self.num_sequences = len(self.data) if self.data else 0\n        self.total_length = sum(len(seq) for seq in self.data) if self.data else 0\n        self.average_length = self.total_length / self.num_sequences if self.num_sequences &gt; 0 else 0\n\n    def _validate_dna_data(self, data):\n        \"\"\"\n        Validates that the input is a proper list of DNA sequences.\n\n        :param data: The data to validate\n        :raises TypeError: If data is not a list\n        :raises ValueError: If data is empty or contains invalid sequences\n        \"\"\"\n        # Check if data is a list\n        if not isinstance(data, list):\n            raise TypeError(f\"DNA data must be a list, got {type(data).__name__}\")\n\n        # Check if data is empty\n        if len(data) == 0:\n            raise ValueError(\"DNA data cannot be empty\")\n\n        # Check if all elements are valid DNA sequences\n        valid_nucleotides = {'A', 'C', 'G', 'T'}\n\n        for i, sequence in enumerate(data):\n            #print((isinstance(sequence, list) and len(sequence) == 2), 'sequence in insilicodna validation')\n            if not isinstance(sequence, str) and not (isinstance(sequence, list) and len(sequence) == 2):\n                raise ValueError(f\"DNA sequence at index {i} must be a string, \"\n                               f\"got {type(sequence).__name__}\")\n\n            if len(sequence) == 0:\n                raise ValueError(f\"DNA sequence at index {i} cannot be empty\")\n\n            # Check if all characters are valid nucleotides\n            if isinstance(sequence, list) and len(sequence) == 2:\n                invalid_chars = set()\n                for seq in sequence:\n                    invalid_chars.update(char for char in seq if char not in valid_nucleotides)\n            else:\n                invalid_chars = set(char for char in sequence if char not in valid_nucleotides)\n            if invalid_chars:\n                raise ValueError(f\"DNA sequence at index {i} contains invalid nucleotides: {invalid_chars}. \"\n                               f\"Only {sorted(valid_nucleotides)} are allowed.\")\n\n    def _flatten_encoded_data(self, encoded_data):\n        \"\"\"\n        Converts nested encoded data structure to flat list of DNA sequences.\n\n        :param encoded_data: Nested list structure from EncodedData\n        :return: List of DNA sequence strings\n        \"\"\"\n        sequences = []\n        for codeword in encoded_data:\n            # Flatten each codeword and join nucleotides into sequences\n            flattened = self._flatten_recursive(codeword)\n            sequence = ''.join(flattened)\n            if sequence:  # Only add non-empty sequences\n                sequences.append(sequence)\n        return sequences\n\n    def _flatten_recursive(self, structure):\n        \"\"\"\n        Recursively flattens nested structure to get nucleotides.\n\n        :param structure: Nested structure to flatten\n        :return: List of nucleotides\n        \"\"\"\n        result = []\n        if isinstance(structure, list):\n            for item in structure:\n                result.extend(self._flatten_recursive(item))\n        else:\n            result.append(structure)\n        return result\n\n    def get_sequence(self, index):\n        \"\"\"\n        Get a specific DNA sequence by index.\n\n        :param index: Index of the sequence\n        :return: The DNA sequence at the specified index\n        :raises IndexError: If index is out of range\n        \"\"\"\n        if not 0 &lt;= index &lt; len(self.data):\n            raise IndexError(f\"DNA sequence index {index} out of range (0-{len(self.data)-1})\")\n        return self.data[index]\n\n    def add_sequence(self, sequence):\n        \"\"\"\n        Add a new DNA sequence to the collection.\n\n        :param sequence: DNA sequence string to add\n        :raises ValueError: If sequence is invalid\n        \"\"\"\n        # Validate the sequence\n        valid_nucleotides = {'A', 'C', 'G', 'T'}\n        if not isinstance(sequence, str):\n            raise ValueError(f\"DNA sequence must be a string, got {type(sequence).__name__}\")\n\n        if len(sequence) == 0:\n            raise ValueError(\"DNA sequence cannot be empty\")\n\n        invalid_chars = set(char for char in sequence if char not in valid_nucleotides)\n        if invalid_chars:\n            raise ValueError(f\"DNA sequence contains invalid nucleotides: {invalid_chars}. \"\n                           f\"Only {sorted(valid_nucleotides)} are allowed.\")\n\n        # Add the sequence and update metrics\n        self.data.append(sequence)\n        self.num_sequences = len(self.data)\n        self.total_length = sum(len(seq) for seq in self.data)\n        self.average_length = self.total_length / self.num_sequences\n\n    def remove_sequence(self, index):\n        \"\"\"\n        Remove a DNA sequence by index.\n\n        :param index: Index of the sequence to remove\n        :raises IndexError: If index is out of range\n        \"\"\"\n        if not 0 &lt;= index &lt; len(self.data):\n            raise IndexError(f\"DNA sequence index {index} out of range (0-{len(self.data)-1})\")\n\n        self.data.pop(index)\n        self.num_sequences = len(self.data)\n        self.total_length = sum(len(seq) for seq in self.data) if self.data else 0\n        self.average_length = self.total_length / self.num_sequences if self.num_sequences &gt; 0 else 0\n\n    def get_sequence_lengths(self):\n        \"\"\"\n        Get lengths of all DNA sequences.\n\n        :return: List of sequence lengths\n        \"\"\"\n        return [len(seq) for seq in self.data]\n\n    def get_nucleotide_counts(self):\n        \"\"\"\n        Get counts of each nucleotide across all sequences.\n\n        :return: Dictionary with nucleotide counts\n        \"\"\"\n        counts = {'A': 0, 'C': 0, 'G': 0, 'T': 0}\n        for sequence in self.data:\n            for nucleotide in sequence:\n                if nucleotide in counts:\n                    counts[nucleotide] += 1\n        return counts\n\n    def validate(self):\n        \"\"\"\n        Re-validates the current DNA data structure.\n\n        :return: True if valid\n        :raises: Various exceptions if invalid\n        \"\"\"\n        self._validate_dna_data(self.data)\n        return True\n\n\n    def random(m, n):\n        \"\"\"\n        Generate m random nucleotide sequences of length n.\n\n        Parameters:\n        -----------\n        m : int\n            Number of sequences to generate\n        n : int\n            Length of each sequence\n\n        Returns:\n        --------\n        InSilicoDNA\n            An InSilicoDNA object containing m random DNA sequences, each of length n\n\n        \"\"\"\n        if m &lt;= 0:\n            raise ValueError(\"Number of sequences (m) must be positive\")\n        if n &lt;= 0:\n            raise ValueError(\"Sequence length (n) must be positive\")\n\n        sequences = []\n\n        for _ in range(m):\n            sequence = ''.join(random.choice('ACGT') for _ in range(n))\n            sequences.append(sequence)\n\n        data = InSilicoDNA(sequences)\n\n        return data\n\n\n    def __str__(self):\n        output = f\"Type: {type(self).__name__}\\n\"\n        output += f\"Number of sequences: {self.num_sequences}\\n\"\n        output += f\"Total length: {self.total_length} nucleotides\\n\"\n        output += f\"Average length: {self.average_length:.1f} nucleotides\\n\"\n\n        # Add file paths if they exist\n        if hasattr(self, 'file_paths') and self.file_paths:\n            output += f\"File paths: {self.file_paths}\\n\"\n\n        if hasattr(self, 'size') and self.size:\n            output += f\"Original size: {self.size} bytes\\n\"\n\n        # Show nucleotide distribution\n        counts = self.get_nucleotide_counts()\n        total_nucleotides = sum(counts.values())\n        if total_nucleotides &gt; 0:\n            output += \"Nucleotide distribution: \"\n            output += \", \".join(f\"{nt}: {count} ({100*count/total_nucleotides:.1f}%)\" \n                              for nt, count in counts.items())\n            output += \"\\n\"\n\n        output += f\"DATA: {str(self.data)[:100]}...\\n\"\n        return output\n\n    def __len__(self):\n        \"\"\"Return the number of DNA sequences.\"\"\"\n        return len(self.data)\n\n    def __getitem__(self, index):\n        \"\"\"Allow indexing to get DNA sequences.\"\"\"\n        return self.get_sequence(index)\n\n    def __iter__(self):\n        \"\"\"Allow iteration over DNA sequences.\"\"\"\n        return iter(self.data)\n</code></pre>"},{"location":"reference/#dnabyte.data_classes.insilicodna.InSilicoDNA.__getitem__","title":"<code>__getitem__(index)</code>","text":"<p>Allow indexing to get DNA sequences.</p> Source code in <code>dnabyte/data_classes/insilicodna.py</code> <pre><code>def __getitem__(self, index):\n    \"\"\"Allow indexing to get DNA sequences.\"\"\"\n    return self.get_sequence(index)\n</code></pre>"},{"location":"reference/#dnabyte.data_classes.insilicodna.InSilicoDNA.__init__","title":"<code>__init__(data)</code>","text":"<p>Creates a DNA object from DNA sequences.</p> <p>:param data: List of DNA sequences (strings).</p> Source code in <code>dnabyte/data_classes/insilicodna.py</code> <pre><code>def __init__(self, data):\n    \"\"\"\n    Creates a DNA object from DNA sequences.\n\n    :param data: List of DNA sequences (strings).\n    \"\"\"\n\n    # Initialize directly from DNA sequences\n    self._validate_dna_data(data)\n    self.data = data\n    self.file_paths = []\n    self.size = None\n\n    # Calculate metrics\n    self.num_sequences = len(self.data) if self.data else 0\n    self.total_length = sum(len(seq) for seq in self.data) if self.data else 0\n    self.average_length = self.total_length / self.num_sequences if self.num_sequences &gt; 0 else 0\n</code></pre>"},{"location":"reference/#dnabyte.data_classes.insilicodna.InSilicoDNA.__iter__","title":"<code>__iter__()</code>","text":"<p>Allow iteration over DNA sequences.</p> Source code in <code>dnabyte/data_classes/insilicodna.py</code> <pre><code>def __iter__(self):\n    \"\"\"Allow iteration over DNA sequences.\"\"\"\n    return iter(self.data)\n</code></pre>"},{"location":"reference/#dnabyte.data_classes.insilicodna.InSilicoDNA.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of DNA sequences.</p> Source code in <code>dnabyte/data_classes/insilicodna.py</code> <pre><code>def __len__(self):\n    \"\"\"Return the number of DNA sequences.\"\"\"\n    return len(self.data)\n</code></pre>"},{"location":"reference/#dnabyte.data_classes.insilicodna.InSilicoDNA.add_sequence","title":"<code>add_sequence(sequence)</code>","text":"<p>Add a new DNA sequence to the collection.</p> <p>:param sequence: DNA sequence string to add :raises ValueError: If sequence is invalid</p> Source code in <code>dnabyte/data_classes/insilicodna.py</code> <pre><code>def add_sequence(self, sequence):\n    \"\"\"\n    Add a new DNA sequence to the collection.\n\n    :param sequence: DNA sequence string to add\n    :raises ValueError: If sequence is invalid\n    \"\"\"\n    # Validate the sequence\n    valid_nucleotides = {'A', 'C', 'G', 'T'}\n    if not isinstance(sequence, str):\n        raise ValueError(f\"DNA sequence must be a string, got {type(sequence).__name__}\")\n\n    if len(sequence) == 0:\n        raise ValueError(\"DNA sequence cannot be empty\")\n\n    invalid_chars = set(char for char in sequence if char not in valid_nucleotides)\n    if invalid_chars:\n        raise ValueError(f\"DNA sequence contains invalid nucleotides: {invalid_chars}. \"\n                       f\"Only {sorted(valid_nucleotides)} are allowed.\")\n\n    # Add the sequence and update metrics\n    self.data.append(sequence)\n    self.num_sequences = len(self.data)\n    self.total_length = sum(len(seq) for seq in self.data)\n    self.average_length = self.total_length / self.num_sequences\n</code></pre>"},{"location":"reference/#dnabyte.data_classes.insilicodna.InSilicoDNA.get_nucleotide_counts","title":"<code>get_nucleotide_counts()</code>","text":"<p>Get counts of each nucleotide across all sequences.</p> <p>:return: Dictionary with nucleotide counts</p> Source code in <code>dnabyte/data_classes/insilicodna.py</code> <pre><code>def get_nucleotide_counts(self):\n    \"\"\"\n    Get counts of each nucleotide across all sequences.\n\n    :return: Dictionary with nucleotide counts\n    \"\"\"\n    counts = {'A': 0, 'C': 0, 'G': 0, 'T': 0}\n    for sequence in self.data:\n        for nucleotide in sequence:\n            if nucleotide in counts:\n                counts[nucleotide] += 1\n    return counts\n</code></pre>"},{"location":"reference/#dnabyte.data_classes.insilicodna.InSilicoDNA.get_sequence","title":"<code>get_sequence(index)</code>","text":"<p>Get a specific DNA sequence by index.</p> <p>:param index: Index of the sequence :return: The DNA sequence at the specified index :raises IndexError: If index is out of range</p> Source code in <code>dnabyte/data_classes/insilicodna.py</code> <pre><code>def get_sequence(self, index):\n    \"\"\"\n    Get a specific DNA sequence by index.\n\n    :param index: Index of the sequence\n    :return: The DNA sequence at the specified index\n    :raises IndexError: If index is out of range\n    \"\"\"\n    if not 0 &lt;= index &lt; len(self.data):\n        raise IndexError(f\"DNA sequence index {index} out of range (0-{len(self.data)-1})\")\n    return self.data[index]\n</code></pre>"},{"location":"reference/#dnabyte.data_classes.insilicodna.InSilicoDNA.get_sequence_lengths","title":"<code>get_sequence_lengths()</code>","text":"<p>Get lengths of all DNA sequences.</p> <p>:return: List of sequence lengths</p> Source code in <code>dnabyte/data_classes/insilicodna.py</code> <pre><code>def get_sequence_lengths(self):\n    \"\"\"\n    Get lengths of all DNA sequences.\n\n    :return: List of sequence lengths\n    \"\"\"\n    return [len(seq) for seq in self.data]\n</code></pre>"},{"location":"reference/#dnabyte.data_classes.insilicodna.InSilicoDNA.random","title":"<code>random(m, n)</code>","text":"<p>Generate m random nucleotide sequences of length n.</p>"},{"location":"reference/#dnabyte.data_classes.insilicodna.InSilicoDNA.random--parameters","title":"Parameters:","text":"<p>m : int     Number of sequences to generate n : int     Length of each sequence</p>"},{"location":"reference/#dnabyte.data_classes.insilicodna.InSilicoDNA.random--returns","title":"Returns:","text":"<p>InSilicoDNA     An InSilicoDNA object containing m random DNA sequences, each of length n</p> Source code in <code>dnabyte/data_classes/insilicodna.py</code> <pre><code>def random(m, n):\n    \"\"\"\n    Generate m random nucleotide sequences of length n.\n\n    Parameters:\n    -----------\n    m : int\n        Number of sequences to generate\n    n : int\n        Length of each sequence\n\n    Returns:\n    --------\n    InSilicoDNA\n        An InSilicoDNA object containing m random DNA sequences, each of length n\n\n    \"\"\"\n    if m &lt;= 0:\n        raise ValueError(\"Number of sequences (m) must be positive\")\n    if n &lt;= 0:\n        raise ValueError(\"Sequence length (n) must be positive\")\n\n    sequences = []\n\n    for _ in range(m):\n        sequence = ''.join(random.choice('ACGT') for _ in range(n))\n        sequences.append(sequence)\n\n    data = InSilicoDNA(sequences)\n\n    return data\n</code></pre>"},{"location":"reference/#dnabyte.data_classes.insilicodna.InSilicoDNA.remove_sequence","title":"<code>remove_sequence(index)</code>","text":"<p>Remove a DNA sequence by index.</p> <p>:param index: Index of the sequence to remove :raises IndexError: If index is out of range</p> Source code in <code>dnabyte/data_classes/insilicodna.py</code> <pre><code>def remove_sequence(self, index):\n    \"\"\"\n    Remove a DNA sequence by index.\n\n    :param index: Index of the sequence to remove\n    :raises IndexError: If index is out of range\n    \"\"\"\n    if not 0 &lt;= index &lt; len(self.data):\n        raise IndexError(f\"DNA sequence index {index} out of range (0-{len(self.data)-1})\")\n\n    self.data.pop(index)\n    self.num_sequences = len(self.data)\n    self.total_length = sum(len(seq) for seq in self.data) if self.data else 0\n    self.average_length = self.total_length / self.num_sequences if self.num_sequences &gt; 0 else 0\n</code></pre>"},{"location":"reference/#dnabyte.data_classes.insilicodna.InSilicoDNA.validate","title":"<code>validate()</code>","text":"<p>Re-validates the current DNA data structure.</p> <p>:return: True if valid :raises: Various exceptions if invalid</p> Source code in <code>dnabyte/data_classes/insilicodna.py</code> <pre><code>def validate(self):\n    \"\"\"\n    Re-validates the current DNA data structure.\n\n    :return: True if valid\n    :raises: Various exceptions if invalid\n    \"\"\"\n    self._validate_dna_data(self.data)\n    return True\n</code></pre>"},{"location":"reference/#core-modules","title":"Core Modules","text":""},{"location":"reference/#params","title":"Params","text":"Source code in <code>dnabyte/params.py</code> <pre><code>class Params:\n\n    def __init__(self, debug=False, **kwargs):\n\n        # Set default values for required attributes\n        self.encoding_method = None\n        self.synthesis_method = None\n        self.storage_conditions = None\n        self.sequencing_method = None\n        self.binarization_method = None\n        self.error_methods = None\n\n        # Set parameters from kwargs\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n        self.debug = debug\n\n        # Load plugins\n        self.binarization_plugins, self.encoding_plugins, self.storage_plugins, self.sequencing_plugins, self.error_plugins  = load_plugins(self.binarization_method, self.encoding_method, self.storage_conditions, self.sequencing_method, self.error_methods)\n\n        # Check binarization parameters\n        if self.binarization_method is None:\n            pass\n        elif self.binarization_method in self.binarization_plugins:\n            binarization = importlib.import_module(f\"dnabyte.binarization.{self.binarization_method}.binarize\")\n            attributes_bin = binarization.attributes(self)\n            for keys, value in attributes_bin.items():\n                setattr(self, keys, value)\n        else:\n            raise ValueError(f\"Invalid binarization method: {self.binarization_method}\")\n        #print(self)\n        # Check encoding parameters\n        if self.encoding_method is None:\n            pass\n        elif self.encoding_method in self.encoding_plugins:\n            encoding = importlib.import_module(f\"dnabyte.encoding.{self.encoding_method}.encode\")\n            attributes_enc = encoding.attributes(self) \n            for keys, value in attributes_enc.items():\n                setattr(self, keys, value)\n        else:\n            raise ValueError(f\"Invalid encoding method: {self.encoding_method}\")\n\n        self.synthesis_plugins = load_synthesis_plugins(self.synthesis_method)\n\n        # Check synthesis parameters\n        if self.synthesis_method is None:\n            pass\n        elif self.synthesis_method in self.synthesis_plugins:\n            synthesis = importlib.import_module(f\"dnabyte.synthesis.{self.synthesis_method}.synthesize\")\n            attributes_synth = synthesis.attributes(self)\n            for keys, value in attributes_synth.items():\n                setattr(self, keys, value)\n        else:\n            raise ValueError(f\"Invalid synthesis method: {self.synthesis_method}\")\n\n        # Check storage parameters\n        if self.storage_conditions is None:\n            pass\n        elif isinstance(self.storage_conditions, list):\n            storage_params_list = []\n            self.years_list = self.years\n            if isinstance(self.years, int):\n                self.years_list = [self.years] * len(self.storage_conditions)\n            for i, condition in enumerate(self.storage_conditions):\n                dict_of_attributes = {}\n                if condition in self.storage_plugins:\n                    storage = importlib.import_module(f\"dnabyte.storage.{condition}.store\")\n                    if i &lt; len(self.years_list):\n                        setattr(self, 'years', self.years_list[i])\n                    else:\n                        setattr(self, 'years', None)\n                    attributes_store = storage.attributes(self)\n                    delattr(self, 'years')\n                    for keys, value in attributes_store.items():\n                        dict_of_attributes[keys] = value\n                    storage_params_list.append(dict_of_attributes)\n                else:\n                    raise ValueError(f\"Invalid storage condition: {condition}\")\n            self.storage_params_list = storage_params_list\n        elif isinstance(self.storage_conditions, str) and self.storage_conditions in self.storage_plugins:\n\n            dict_of_attributes = {}\n            storage = importlib.import_module(f\"dnabyte.storage.{self.storage_conditions}.store\")\n            attributes_store = storage.attributes(self)\n            for keys, value in attributes_store.items():\n                dict_of_attributes[keys] = value\n            self.storage_params = dict_of_attributes\n        else:\n            raise ValueError(f\"Invalid storage conditions: {self.storage_conditions}\")\n\n        #print(self.error_plugins, 'error plugins in params')\n\n        # Check error parameters\n        if self.error_methods is None:\n            pass\n        elif isinstance(self.error_methods, list):\n            error_params_list = {}\n            for i, condition in enumerate(self.error_methods):\n                dict_of_attributes = {}\n                if condition in self.error_plugins:\n                    errs = importlib.import_module(f\"dnabyte.misc_errors.{condition}.err\")\n                    if not hasattr(self, 'error_params_temp'):\n                        pass\n                    elif isinstance(self.error_params_temp, dict):\n                        if condition in self.error_params_temp:\n                            for key, value in self.error_params_temp[condition].items():\n                                setattr(self, key, value)\n                        delattr(self, 'error_params_temp')\n                    attributes_store = errs.attributes(self)\n                    for keys, value in attributes_store.items():\n                        dict_of_attributes[keys] = value\n                    error_params_list.update({condition: dict_of_attributes})\n                else:\n                    raise ValueError(f\"Invalid storage condition: {condition}\")\n            setattr(self, 'error_params_list', error_params_list)\n            delattr(self, 'error_params')\n            #print(self.error_params_list, 'error params list in params')\n        elif isinstance(self.error_methods, str) and self.error_methods in self.error_plugins:\n\n            dict_of_attributes = {}\n            errs = importlib.import_module(f\"dnabyte.misc_errors.{self.error_methods}.err\")\n            attributes_err = errs.attributes(self)\n            for keys, value in attributes_err.items():\n                dict_of_attributes[keys] = value\n            setattr(self, 'error_params', dict_of_attributes)\n        else:\n            raise ValueError(f\"Invalid error methods: {self.error_methods}\")\n        # Check sequencing parameters\n        if self.sequencing_method is None:\n            pass\n        elif self.sequencing_method in self.sequencing_plugins:\n            sequencing = importlib.import_module(f\"dnabyte.sequencing.{self.sequencing_method}.sequence\")\n            attributes_seq = sequencing.attributes(self)\n            for keys, value in attributes_seq.items():\n                setattr(self, keys, value)\n        else:\n            raise ValueError(f\"Invalid sequencing method: {self.sequencing_method}\")\n\n\n    def __str__(self):\n        output = \"Params:\\n\"\n        for key, value in self.__dict__.items():\n            output += f\"  {key}: {value}\\n\"\n        return output\n\n    @classmethod\n    def params_range(cls, **kwargs):\n        \"\"\"\n        Alternative constructor that creates a list of Params instances for each item in the list if one of the \n        parameters is a non-empty list.\n\n        Parameters:\n        kwargs (dict): The parameters for the Params instances.\n\n        Returns:\n        list: A list of Params instances.\n        \"\"\"\n        params_list = []\n\n        # Attributes that should not be treated as range parameters (must remain as lists)\n        excluded_attrs = {'file_paths'}\n\n        # Find the first attribute that is a non-empty list (excluding special attributes)\n        for attr_name, attr_value in kwargs.items():\n            if attr_name not in excluded_attrs and isinstance(attr_value, list) and attr_value:\n                for item in attr_value:\n                    new_kwargs = {**kwargs, attr_name: item}\n                    params_list.append(cls(**new_kwargs))\n                break\n        else:\n            # If no attribute is a non-empty list, return a list with a single instance\n            params_list.append(cls(**kwargs))\n\n        return params_list\n</code></pre>"},{"location":"reference/#dnabyte.params.Params.params_range","title":"<code>params_range(**kwargs)</code>  <code>classmethod</code>","text":"<p>Alternative constructor that creates a list of Params instances for each item in the list if one of the  parameters is a non-empty list.</p> <p>Parameters: kwargs (dict): The parameters for the Params instances.</p> <p>Returns: list: A list of Params instances.</p> Source code in <code>dnabyte/params.py</code> <pre><code>@classmethod\ndef params_range(cls, **kwargs):\n    \"\"\"\n    Alternative constructor that creates a list of Params instances for each item in the list if one of the \n    parameters is a non-empty list.\n\n    Parameters:\n    kwargs (dict): The parameters for the Params instances.\n\n    Returns:\n    list: A list of Params instances.\n    \"\"\"\n    params_list = []\n\n    # Attributes that should not be treated as range parameters (must remain as lists)\n    excluded_attrs = {'file_paths'}\n\n    # Find the first attribute that is a non-empty list (excluding special attributes)\n    for attr_name, attr_value in kwargs.items():\n        if attr_name not in excluded_attrs and isinstance(attr_value, list) and attr_value:\n            for item in attr_value:\n                new_kwargs = {**kwargs, attr_name: item}\n                params_list.append(cls(**new_kwargs))\n            break\n    else:\n        # If no attribute is a non-empty list, return a list with a single instance\n        params_list.append(cls(**kwargs))\n\n    return params_list\n</code></pre>"},{"location":"reference/#library","title":"Library","text":"<p>A class to represent a DNA oligo library.</p> Source code in <code>dnabyte/library.py</code> <pre><code>class Library:\n    \"\"\"\n    A class to represent a DNA oligo library.\n    \"\"\"\n\n    def __init__(self, structure='linear_assembly', library=None, **kwargs):\n        \"\"\"\n        Initialize a Library object.\n\n        :param structure: The structure of the library indicated by a string 'simple' (default) or 'poly'.\n        :param library: The library data, default is None.\n        :param kwargs: Additional keyword arguments.\n        \"\"\"\n        self.structure = structure\n\n        if library:\n            self.library = library\n        elif 'filename' in kwargs and self.structure == 'linear_assembly':\n            self.library = self.read_library(kwargs['filename'])\n            self.leftmotives, self.rightmotives, self.dictmotives, self.translationlibleft, self.translationlibright = self.motive_pairs()\n\n\n        elif 'filename' in kwargs and self.structure == 'positional_assembly':\n            self.messages, self.generic, self.position  = self.read_library_poly(kwargs['filename'])\n            self.library = [self.messages, self.generic, self.position]\n            self.messageleft, self.messageright, self.genericlib, self.connectorlib, self.dictmotives = self.motive_pairs_poly()\n\n\n    @classmethod\n    def read_library(cls, file_path):\n        \"\"\"\n        Read the library data from a file.\n\n        :param file_path: Path to the file containing the library data.\n        :return: A list of DNA sequences.\n        \"\"\"\n        # TODO: Fallunterscheidung mit fasta und .csv\n        # TODO: make it an actual class method\n        # TODO: check if read in library is correct\n\n\n        DNAs = []\n        with open(file_path) as csv_file:\n            csv_reader = csv.reader(csv_file, delimiter=',')\n            for row in csv_reader:    \n                DNAs.append(row[0])\n        return DNAs      \n\n    @classmethod\n    def read_library_poly(cls, file_path):\n\n        # TODO: check if read in library is correct\n\n        DNAs = []\n        with open(file_path) as csv_file:\n            csv_reader = csv.reader(csv_file, delimiter=',')\n            for row in csv_reader:    \n                DNAs.append(row[0])\n\n        messages = DNAs[1:DNAs.index('Generic')]\n        generic = DNAs[DNAs.index('Generic')+1:DNAs.index('Connector')]\n        positions = DNAs[DNAs.index('Connector')+1:]\n\n        return messages,  generic, positions\n\n    def complementmap(self, string):\n        compliment = ''\n        for i in string:\n            if i == 'A':\n                compliment += 'T'\n            if i == 'T':\n                compliment += 'A'\n            if i == 'C':\n                compliment += 'G'\n            if i == 'G':\n                compliment += 'C'\n        compliment = compliment[::-1]\n        return compliment\n\n    def motive_pairs(self):\n        \"\"\"\n        Generate motive pairs from the library data.\n\n        :param library: The library data.\n        :return: A tuple containing left motifs, right motifs, a dictionary of motives,\n             translation library for left motifs, and translation library for right motifs.\n        \"\"\"\n        DNAs = self.library\n        oligolen = len(DNAs[0])\n        oligolenhalf = oligolen // 2\n        leftmotifs = []\n        rightmotifs = []\n\n        for dna in DNAs:\n            left_motif = dna[:oligolenhalf]\n            right_motif = dna[oligolenhalf:]\n\n            if left_motif not in leftmotifs and self.complementmap(left_motif) not in leftmotifs:\n                leftmotifs.append(left_motif)\n            if right_motif not in rightmotifs and self.complementmap(right_motif) not in rightmotifs:\n                rightmotifs.append(right_motif) \n\n        leftmotifs.sort()\n        rightmotifs.sort()\n\n        translationlibleft = {}\n        translationlibright = {}\n        dictmotives = {}\n\n        for i, motif in enumerate(leftmotifs):\n            translationlibleft[motif] = chr(97 + i)\n            translationlibleft[self.complementmap(motif)] = chr(97 + i) + '*'\n            dictmotives[chr(97 + i)] = chr(97 + i) + '*'\n            dictmotives[chr(97 + i) + '*'] = chr(97 + i)\n\n        for i, motif in enumerate(rightmotifs):\n            translationlibright[motif] = chr(65 + i)\n            translationlibright[self.complementmap(motif)] = chr(65 + i) + '*'\n            dictmotives[chr(65 + i)] = chr(65 + i) + '*'\n            dictmotives[chr(65 + i) + '*'] = chr(65 + i)\n\n        dictmotives['empty'] = 'empty*'\n        dictmotives['empty*'] = 'empty'\n        dictmotives[None] = None\n\n        return leftmotifs, rightmotifs, dictmotives, translationlibleft, translationlibright\n\n    def motive_pairs_poly(self):\n        \"\"\"\n        Generate motive pairs from the library data.\n\n        :param library: The library data.\n        :return: A tuple containing left motifs, right motifs, a dictionary of motives,\n             translation library for left motifs, and translation library for right motifs.\n        \"\"\"\n\n        messagelibleft = {}\n        message_libright = {}\n        genericlib = {}\n        connectorlib = {}\n        dictmotives = {}\n        messagesleft =[]\n        messagesright = []\n\n        for i in range(len(self.messages)):\n            messagesleft.append(self.messages[i][:len(self.messages[i])//2])\n            messagesright.append(self.messages[i][len(self.messages[i])//2:])\n        # messagesleft = list(set(messagesleft))\n        # messagesright = list(set(messagesright))\n        # messagesleft.sort()\n        # messagesright.sort()\n\n        for i, motif in enumerate(messagesleft):\n            messagelibleft[motif] = 'ml' + str(i)\n            messagelibleft[self.complementmap(motif)] = 'ml' + str(i) + '*'\n            dictmotives['ml' + str(i)] = 'ml' + str(i) + '*'\n            dictmotives['ml' + str(i) + '*'] = 'ml' + str(i)\n\n        for i, motif in enumerate(messagesright):\n            message_libright[motif] = 'mr' + str(i)\n            message_libright[self.complementmap(motif)] = 'mr' + str(i) + '*'\n            dictmotives['mr' + str(i)] = 'mr' + str(i) + '*'\n            dictmotives['mr' + str(i) + '*'] = 'mr' + str(i)\n\n        for i, motif in enumerate(self.generic):\n            genericlib[motif] = 'g' + str(i)\n            genericlib[self.complementmap(motif)] = 'g' + str(i) + '*'\n            dictmotives['g' + str(i)] = 'g' + str(i) + '*'\n            dictmotives['g' + str(i) + '*'] = 'g' + str(i)\n\n        for i, motif in enumerate(self.position):\n            connectorlib[motif] = 'c' + str(i)\n            connectorlib[self.complementmap(motif)] = 'c' + str(i)+ '*'\n            dictmotives['c' + str(i)] = 'c' + str(i) + '*'\n            dictmotives['c' + str(i) + '*'] = 'c' + str(i)\n\n        dictmotives['empty'] = 'empty*'\n        dictmotives['empty*'] = 'empty'\n        dictmotives[None]= None\n\n        return messagelibleft, message_libright, genericlib, connectorlib, dictmotives\n</code></pre>"},{"location":"reference/#dnabyte.library.Library.__init__","title":"<code>__init__(structure='linear_assembly', library=None, **kwargs)</code>","text":"<p>Initialize a Library object.</p> <p>:param structure: The structure of the library indicated by a string 'simple' (default) or 'poly'. :param library: The library data, default is None. :param kwargs: Additional keyword arguments.</p> Source code in <code>dnabyte/library.py</code> <pre><code>def __init__(self, structure='linear_assembly', library=None, **kwargs):\n    \"\"\"\n    Initialize a Library object.\n\n    :param structure: The structure of the library indicated by a string 'simple' (default) or 'poly'.\n    :param library: The library data, default is None.\n    :param kwargs: Additional keyword arguments.\n    \"\"\"\n    self.structure = structure\n\n    if library:\n        self.library = library\n    elif 'filename' in kwargs and self.structure == 'linear_assembly':\n        self.library = self.read_library(kwargs['filename'])\n        self.leftmotives, self.rightmotives, self.dictmotives, self.translationlibleft, self.translationlibright = self.motive_pairs()\n\n\n    elif 'filename' in kwargs and self.structure == 'positional_assembly':\n        self.messages, self.generic, self.position  = self.read_library_poly(kwargs['filename'])\n        self.library = [self.messages, self.generic, self.position]\n        self.messageleft, self.messageright, self.genericlib, self.connectorlib, self.dictmotives = self.motive_pairs_poly()\n</code></pre>"},{"location":"reference/#dnabyte.library.Library.motive_pairs","title":"<code>motive_pairs()</code>","text":"<p>Generate motive pairs from the library data.</p> <p>:param library: The library data. :return: A tuple containing left motifs, right motifs, a dictionary of motives,      translation library for left motifs, and translation library for right motifs.</p> Source code in <code>dnabyte/library.py</code> <pre><code>def motive_pairs(self):\n    \"\"\"\n    Generate motive pairs from the library data.\n\n    :param library: The library data.\n    :return: A tuple containing left motifs, right motifs, a dictionary of motives,\n         translation library for left motifs, and translation library for right motifs.\n    \"\"\"\n    DNAs = self.library\n    oligolen = len(DNAs[0])\n    oligolenhalf = oligolen // 2\n    leftmotifs = []\n    rightmotifs = []\n\n    for dna in DNAs:\n        left_motif = dna[:oligolenhalf]\n        right_motif = dna[oligolenhalf:]\n\n        if left_motif not in leftmotifs and self.complementmap(left_motif) not in leftmotifs:\n            leftmotifs.append(left_motif)\n        if right_motif not in rightmotifs and self.complementmap(right_motif) not in rightmotifs:\n            rightmotifs.append(right_motif) \n\n    leftmotifs.sort()\n    rightmotifs.sort()\n\n    translationlibleft = {}\n    translationlibright = {}\n    dictmotives = {}\n\n    for i, motif in enumerate(leftmotifs):\n        translationlibleft[motif] = chr(97 + i)\n        translationlibleft[self.complementmap(motif)] = chr(97 + i) + '*'\n        dictmotives[chr(97 + i)] = chr(97 + i) + '*'\n        dictmotives[chr(97 + i) + '*'] = chr(97 + i)\n\n    for i, motif in enumerate(rightmotifs):\n        translationlibright[motif] = chr(65 + i)\n        translationlibright[self.complementmap(motif)] = chr(65 + i) + '*'\n        dictmotives[chr(65 + i)] = chr(65 + i) + '*'\n        dictmotives[chr(65 + i) + '*'] = chr(65 + i)\n\n    dictmotives['empty'] = 'empty*'\n    dictmotives['empty*'] = 'empty'\n    dictmotives[None] = None\n\n    return leftmotifs, rightmotifs, dictmotives, translationlibleft, translationlibright\n</code></pre>"},{"location":"reference/#dnabyte.library.Library.motive_pairs_poly","title":"<code>motive_pairs_poly()</code>","text":"<p>Generate motive pairs from the library data.</p> <p>:param library: The library data. :return: A tuple containing left motifs, right motifs, a dictionary of motives,      translation library for left motifs, and translation library for right motifs.</p> Source code in <code>dnabyte/library.py</code> <pre><code>def motive_pairs_poly(self):\n    \"\"\"\n    Generate motive pairs from the library data.\n\n    :param library: The library data.\n    :return: A tuple containing left motifs, right motifs, a dictionary of motives,\n         translation library for left motifs, and translation library for right motifs.\n    \"\"\"\n\n    messagelibleft = {}\n    message_libright = {}\n    genericlib = {}\n    connectorlib = {}\n    dictmotives = {}\n    messagesleft =[]\n    messagesright = []\n\n    for i in range(len(self.messages)):\n        messagesleft.append(self.messages[i][:len(self.messages[i])//2])\n        messagesright.append(self.messages[i][len(self.messages[i])//2:])\n    # messagesleft = list(set(messagesleft))\n    # messagesright = list(set(messagesright))\n    # messagesleft.sort()\n    # messagesright.sort()\n\n    for i, motif in enumerate(messagesleft):\n        messagelibleft[motif] = 'ml' + str(i)\n        messagelibleft[self.complementmap(motif)] = 'ml' + str(i) + '*'\n        dictmotives['ml' + str(i)] = 'ml' + str(i) + '*'\n        dictmotives['ml' + str(i) + '*'] = 'ml' + str(i)\n\n    for i, motif in enumerate(messagesright):\n        message_libright[motif] = 'mr' + str(i)\n        message_libright[self.complementmap(motif)] = 'mr' + str(i) + '*'\n        dictmotives['mr' + str(i)] = 'mr' + str(i) + '*'\n        dictmotives['mr' + str(i) + '*'] = 'mr' + str(i)\n\n    for i, motif in enumerate(self.generic):\n        genericlib[motif] = 'g' + str(i)\n        genericlib[self.complementmap(motif)] = 'g' + str(i) + '*'\n        dictmotives['g' + str(i)] = 'g' + str(i) + '*'\n        dictmotives['g' + str(i) + '*'] = 'g' + str(i)\n\n    for i, motif in enumerate(self.position):\n        connectorlib[motif] = 'c' + str(i)\n        connectorlib[self.complementmap(motif)] = 'c' + str(i)+ '*'\n        dictmotives['c' + str(i)] = 'c' + str(i) + '*'\n        dictmotives['c' + str(i) + '*'] = 'c' + str(i)\n\n    dictmotives['empty'] = 'empty*'\n    dictmotives['empty*'] = 'empty'\n    dictmotives[None]= None\n\n    return messagelibleft, message_libright, genericlib, connectorlib, dictmotives\n</code></pre>"},{"location":"reference/#dnabyte.library.Library.read_library","title":"<code>read_library(file_path)</code>  <code>classmethod</code>","text":"<p>Read the library data from a file.</p> <p>:param file_path: Path to the file containing the library data. :return: A list of DNA sequences.</p> Source code in <code>dnabyte/library.py</code> <pre><code>@classmethod\ndef read_library(cls, file_path):\n    \"\"\"\n    Read the library data from a file.\n\n    :param file_path: Path to the file containing the library data.\n    :return: A list of DNA sequences.\n    \"\"\"\n    # TODO: Fallunterscheidung mit fasta und .csv\n    # TODO: make it an actual class method\n    # TODO: check if read in library is correct\n\n\n    DNAs = []\n    with open(file_path) as csv_file:\n        csv_reader = csv.reader(csv_file, delimiter=',')\n        for row in csv_reader:    \n            DNAs.append(row[0])\n    return DNAs      \n</code></pre>"},{"location":"reference/#oligo","title":"Oligo","text":"<p>This class models a single or double stranded oligonucleotide. It is always instanciated as single stranded, from which double stranded oligonucleotides can be created by hybridising it with another oligo.</p> <p>Attributes:</p> Name Type Description <code>motifs</code> <code>tuple</code> <p>A pair of motifs where the first motif is lowercase (representing the 5' end) and the </p> <code>type</code> <code>str</code> <p>Indicates the type of the oligonucleotide. Defaults to 'single_stranded'.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>motifs</code> is provided but is not a valid motif pair (i.e., a tuple of two elements </p> <p>Parameters:</p> Name Type Description Default <code>motifs</code> <code>tuple</code> <p>A tuple containing a pair of motifs to initialize the oligonucleotide. </p> <code>None</code> Source code in <code>dnabyte/oligo.py</code> <pre><code>class Oligo:\n    \"\"\"\n        This class models a single or double stranded oligonucleotide. It is always instanciated as single stranded,\n        from which double stranded oligonucleotides can be created by hybridising it with another oligo.\n\n        Attributes:\n            motifs (tuple): A pair of motifs where the first motif is lowercase (representing the 5' end) and the \n            second motif is uppercase (representing the 3' end). This attribute is None if no motifs are provided.\n            type (str): Indicates the type of the oligonucleotide. Defaults to 'single_stranded'.\n\n        Raises:\n            ValueError: If `motifs` is provided but is not a valid motif pair (i.e., a tuple of two elements \n            where the first element is lowercase and the second is uppercase).\n\n        Parameters:\n            motifs (tuple, optional): A tuple containing a pair of motifs to initialize the oligonucleotide. \n            Defaults to None.\n        \"\"\"\n\n    def __init__(self, motifs=None, sequence=None, type=None):\n        self.motifs = motifs\n        self.sequence = sequence\n        self.type = type\n\n        if motifs:\n            if isinstance(motifs[0], tuple):\n                self.type = 'double_stranded'\n            if isinstance(motifs[0], str):\n                self.type = 'single_stranded'\n        # TODO: This causes the oligo assignment not to work\n        # Determine the type based on the structure of motifs or sequence\n        # if motifs is not None:\n        #     if isinstance(motifs, list):\n        #         self.type = 'double_stranded'\n        #     elif isinstance(motifs, tuple):\n        #         self.type = 'single_stranded'\n        #     else:\n        #         raise ValueError(\"Invalid motif structure.\")\n\n        # if sequence is not None:\n        #     if isinstance(sequence, list) and all(isinstance(s, str) for s in sequence):\n        #         self.type = 'double_stranded'\n        #     elif isinstance(sequence, str):\n        #         self.type = 'single_stranded'\n        #     else:\n        #         raise ValueError(\"Invalid sequence structure.\")\n        # else:\n        #     #raise ValueError(\"Oligo must be initialized with motifs or sequence.\")\n        #     return None\n\n    def end(self, strand=None, side=None):\n        # If only one argument is provided, it is considered as 'side'\n        if strand is not None and side is None:\n            side, strand = strand, None\n\n        if self.type == 'single_stranded':\n            if side == '5' or side == 'r':\n                return self.motifs[1]\n            elif side == '3' or side == 'l':\n                return self.motifs[0]\n\n        else:\n            if strand == 'f' and (side == '5' or side == 'r'):\n                return self.motifs[0][-1]\n            elif strand == 'f' and (side == '3' or side == 'l'):\n                return self.motifs[0][0]\n            elif strand == 'r' and (side == '5' or side == 'l'):\n                return self.motifs[1][0]\n            elif strand == 'r' and (side == '3' or side == 'r'):\n                return self.motifs[1][-1]\n\n\n    def __str__(self):\n\n        if self.motifs and hasattr(self, 'motifs') and self.type == 'single_stranded':\n            formatted_motif_1 = f\" {self.motifs[0]}  \" if len(self.motifs[0]) == 1 else f\" {self.motifs[0]} \"\n            formatted_motif_2 = f\" {self.motifs[1]}  \" if len(self.motifs[1]) == 1 else f\" {self.motifs[1]} \"\n            return \"3':  ( \" + formatted_motif_1 + \" - \" + formatted_motif_2 + \" )  :5' \\n\"\n\n        elif self.motifs and hasattr(self, 'motifs') and self.type == 'double_stranded':\n            output = \"\"\n            for index, strand in enumerate(self.motifs):\n                line = \"3':  (\" if index == 0 else \"5':  (\"\n\n                for i, motif in enumerate(strand):\n                    if motif:\n                        line += f\" {motif}  \" if len(motif) == 1 else f\" {motif} \"\n                    else:\n                        line += \"    \"\n                    if i &lt; len(strand) - 1:  # Check if it's not the last motif\n                        line += \"-\"\n                line += \")  :5'  \\n\" if index == 0 else \")  :3' \\n\"\n                output += line\n            output += \"\\n\"\n            return output\n\n        elif self.sequence and hasattr(self, 'sequence') and self.type == 'single_stranded':\n            return \"3': \" + self.sequence + \" :5'\"\n\n        elif self.sequence and hasattr(self, 'sequence') and self.type == 'double_stranded':\n            return \"3': \" + self.sequence[0] + \" :5' \\n5': \" + self.sequence[1] + \" :3'\"\n\n        else:\n            return \"Oligo does not have properly defined motifs.\"\n\n    wc_pairs = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\n\n\n    def mirror(self):\n        \"\"\"\n        Returns the identical oligonucleotide, where forward and reverse strand are exchanged.\n        \"\"\"\n        if self.type == 'single_stranded':\n            return self\n        else: \n            return Oligo(motifs=(self.motifs[1][::-1], self.motifs[0][::-1]))\n</code></pre>"},{"location":"reference/#dnabyte.oligo.Oligo.mirror","title":"<code>mirror()</code>","text":"<p>Returns the identical oligonucleotide, where forward and reverse strand are exchanged.</p> Source code in <code>dnabyte/oligo.py</code> <pre><code>def mirror(self):\n    \"\"\"\n    Returns the identical oligonucleotide, where forward and reverse strand are exchanged.\n    \"\"\"\n    if self.type == 'single_stranded':\n        return self\n    else: \n        return Oligo(motifs=(self.motifs[1][::-1], self.motifs[0][::-1]))\n</code></pre>"},{"location":"reference/#oligopool","title":"OligoPool","text":"<p>A class to represent a pool of oligonucleotides.</p> <p>There are two constructors for the OligoPool class: 1. The first constructor takes a list of motifs and generates a pool of oligos with a random copy number for each motif. The distribution of the copy number is set to be normal, rounded to the next integer. The user can set the mean and standard deviation of the distribution.</p> <ol> <li>The second constructor takes a list of OligoPool objects and generates a new pool by combining the oligos in the pools of the input OligoPool objects. The user can also set the number of hybridisation events to be performed on the new pool.</li> </ol> Source code in <code>dnabyte/oligopool.py</code> <pre><code>class OligoPool:\n    \"\"\"\n        A class to represent a pool of oligonucleotides.\n\n        There are two constructors for the OligoPool class:\n        1. The first constructor takes a list of motifs and generates a pool of oligos with a random copy number for each motif.\n        The distribution of the copy number is set to be normal, rounded to the next integer. The user can set the mean and\n        standard deviation of the distribution.\n\n        2. The second constructor takes a list of OligoPool objects and generates a new pool by combining the oligos in the\n        pools of the input OligoPool objects. The user can also set the number of hybridisation events to be performed on the\n        new pool.\n        \"\"\"\n\n    def __init__(self, oligo_list, mean=1, std_dev=0):\n        self.pool = []\n        for oligo in oligo_list:\n            self.pool.extend(self.pipette(oligo, mean, std_dev))\n\n    def pipette(self, oligo, mean, std_dev):\n\n        step = []\n        num_oligos = int(round(np.random.normal(mean, std_dev)))\n        if num_oligos &lt;= 0:\n            num_oligos = 1\n        for _ in range(num_oligos):\n            step.append(oligo)\n        return step\n\n    def join(self, pools, mean, std_dev):\n\n        # Create a new OligoPool instance\n        combined_pool = OligoPool([])\n\n        oligo_pools = [arg for arg in pools if isinstance(arg, OligoPool)]\n        oligos = [arg for arg in pools if isinstance(arg, Oligo)]\n\n        # Extend the pool with elements from other OligoPool instances\n        for pool in oligo_pools:\n            combined_pool.pool.extend(pool.pool)\n\n        # Use the pipette function to append a random copy of the oligos to the pool\n        for oligo in oligos:\n            combined_pool.pool.extend(self.pipette(oligo, mean, std_dev))\n\n        return combined_pool\n\n\n    @classmethod\n    def from_oligo_pools(cls, oligo_pools):\n        new_pool_motifs = []\n        for pool in oligo_pools:\n            #new_pool_motifs.extend(pool.oligo_list)\n            new_pool_motifs.extend(pool.pool)\n\n        new_pool = cls(new_pool_motifs)\n        new_pool.pool = [oligo for pool in oligo_pools for oligo in pool.pool]\n\n        return new_pool\n\n\n    def __str__(self):\n        if self.pool is not None:\n            oligo_counts = {}\n\n            # count occurences of all oligos\n\n            for oligo in self.pool:\n                oligo_key = str(oligo)\n                oligo_key_mirrored = str(oligo.mirror())\n\n                if (oligo_key in oligo_counts):\n                    oligo_counts[oligo_key] += 1\n                elif (oligo_key_mirrored in oligo_counts):\n                    oligo_counts[oligo_key_mirrored] += 1\n                else:\n                    oligo_counts[oligo_key] = 1\n\n            # sort oligos by count, descending\n            sorted_oligos = dict(sorted(oligo_counts.items(), key=lambda item: item[1], reverse=True))\n\n            # generate output string\n            output = \"\"\n            for oligo_key, count in sorted_oligos.items():\n                output += f\"{oligo_key}: {count} \\n \\n\"\n            return output\n\n        else:\n            return \"Oligo pool is empty.\"\n\n\n    def hybridise(self, n, library, info=False):\n\n        # set default value for n\n        if n is None:\n            n = 10*len(self.pool)\n\n        for _ in range(n):\n            if len(self.pool) &gt; 1:  # Ensure there are at least two oligos to hybridize\n                # Randomly pick two distinct oligos\n                oligo_A, oligo_B = random.sample(self.pool, 2)\n\n                # Pair the selected oligos\n                hybridised_oligo = self.pair(oligo_A, oligo_B,library)\n\n                # Check if the hybridisation was successful\n                if hybridised_oligo.motifs:\n                    # Remove the original oligos from the pool\n                    self.pool.remove(oligo_A)\n                    self.pool.remove(oligo_B)\n\n                    # Append the new hybridised oligo to the pool\n                    self.pool.append(hybridised_oligo)\n\n                    #if info:  # Optionally print information about the hybridisation event\n\n\n        return self\n\n\n    def pair(self, oligo_A, oligo_B,library):\n        self.motif_dict=library.dictmotives\n\n        if oligo_A.type == 'single_stranded' and oligo_B.type == 'single_stranded':  \n\n            if complement(oligo_A.end('3'),self.motif_dict) == oligo_B.end('3'):\n                new_motifs = ((None, oligo_A.motifs[0], oligo_A.motifs[1]), (oligo_B.motifs[1], oligo_B.motifs[0], None))\n\n            elif complement(oligo_A.end('5'),self.motif_dict) == oligo_B.end('5'):\n                new_motifs = ((oligo_A.motifs[0], oligo_A.motifs[1], None), (None, oligo_B.motifs[1], oligo_B.motifs[0]))                \n\n            else:\n                return Oligo(None)\n\n            new_oligo = Oligo(new_motifs)\n            return new_oligo\n\n\n        if oligo_A.type == 'double_stranded' and oligo_B.type == 'double_stranded':  \n            if oligo_A.end('f', '5') and oligo_B.end('r', '5') and oligo_A.end('f', '5') == complement(oligo_B.end('r', '5'),self.motif_dict):\n\n                new_motifs = (oligo_A.motifs[0] + oligo_B.motifs[0][1:],    # forward strand\n                                oligo_A.motifs[1][0:-1] + oligo_B.motifs[1])  # reverse strand\n\n            # case: dsA forward 5' sticky end binds to dsB forward 5' sticky end\n            elif oligo_A.end('f', '5') and oligo_B.end('f', '5') and oligo_A.end('f', '5') == complement(oligo_B.end('f', '5'),self.motif_dict):\n\n                new_motifs = (oligo_A.motifs[0] + oligo_B.motifs[1][-2::-1],        # forward strand\n                                oligo_A.motifs[1][0:-1] + oligo_B.motifs[0][::-1])    # reverse strand\n\n            # case: the sticky end is on the reverse strand on the right and on the forward strand on the left\n            elif oligo_A.end('r', '3') and oligo_B.end('f', '3') and oligo_A.end('r', '3') == complement(oligo_B.end('f', '3'),self.motif_dict):\n\n                new_motifs = (oligo_A.motifs[0][0:-1] + oligo_B.motifs[0],    # forward strand\n                                oligo_A.motifs[1] + oligo_B.motifs[1][1:])        # reverse strand\n\n            # case: the sticky ends are on the reverse strands on the right\n\n            elif oligo_A.end('r', '3') and oligo_B.end('r', '3') and oligo_A.end('r', '3') == complement(oligo_B.end('r', '3'),self.motif_dict):\n\n                new_motifs = (oligo_A.motifs[0][:-1] + oligo_B.motifs[1][::-1],    # forward strand\n                                oligo_A.motifs[1] + oligo_B.motifs[0][:-1][::-1])        # reverse strand\n\n            # case: the sticky end is on the forward strand on the left and on the reverse strand on the right\n            elif oligo_A.end('f', '3') and oligo_B.end('r', '3') and oligo_A.end('f', '3') == complement(oligo_B.end('r', '3'),self.motif_dict):\n\n                new_motifs = ( oligo_B.motifs[0][0:-1] + oligo_A.motifs[0],    # forward strand\n                                oligo_B.motifs[1] + oligo_A.motifs[1][1:])  # reverse strand\n\n            # case: the sticky ends are on the forward strand on the left\n            elif oligo_A.end('f', '3') and oligo_B.end('f', '3') and oligo_A.end('f', '3') == complement(oligo_B.end('f', '3'),self.motif_dict):\n\n                new_motifs = ( oligo_B.motifs[1][1:][::-1] + oligo_A.motifs[0],    # forward strand\n                                oligo_B.motifs[0][::-1] + oligo_A.motifs[1][1:])  # reverse strand\n\n            # case: the sticky end is on the reverse strand on the left and the forward strand on the right\n            elif oligo_A.end('r', '5') and oligo_B.end('f', '5') and oligo_A.end('r', '5') == complement(oligo_B.end('f', '5'),self.motif_dict):\n\n                new_motifs = (oligo_B.motifs[0] + oligo_A.motifs[0][1:],    # forward strand\n                                oligo_B.motifs[1][:-1] + oligo_A.motifs[1])  # reverse strand\n\n            # case: the sticky ends are on the reverse strand on the left\n            elif oligo_A.end('r', '5') and oligo_B.end('r', '5') and oligo_A.end('r', '5') == complement(oligo_B.end('r', '5'),self.motif_dict):\n\n                new_motifs = (oligo_B.motifs[1][::-1] + oligo_A.motifs[0][1:],    # forward strand\n                                oligo_B.motifs[0][:0:-1] + oligo_A.motifs[1])  # reverse strand\n\n            else: \n                return Oligo(None) \n\n            return Oligo(new_motifs)\n\n        else: # case where one oligo is single stranded and the other is double stranded\n\n            if oligo_A.type == 'double_stranded' and oligo_B.type == 'single_stranded': \n                ds = oligo_A\n                ss = oligo_B\n            else:\n                ds = oligo_B\n                ss = oligo_A\n\n            # case: double strand forward 5' sticky end binds to ss 5' sticky end\n            if ds.end('f', '5') and ds.end('f', '5') == complement(ss.end('5'),self.motif_dict):\n\n                new_motifs=(ds.motifs[0] + (None,),                                 # forward strand\n                                ds.motifs[1][:-1] + (ss.motifs[1], ss.motifs[0]))   # reverse strand\n\n            # case: ds reverse 3' sticky end binds to ss 3' sticky end\n            elif ds.end('r', '3') and ds.end('r', '3') == complement(ss.end('3'),self.motif_dict):\n\n                new_motifs = (ds.motifs[0][0:-1] + (ss.motifs[0], ss.motifs[1]),    # forward strand\n                                ds.motifs[1] + (None,))                             # reverse strand\n\n            # case: ds forward 3' sticky end binds to ss 5' sticky end\n            elif ds.end('f', '3') and ds.end('f', '3') == complement(ss.end('3'),self.motif_dict):  \n\n                new_motifs = ((None,) + ds.motifs[0],                               # forward strand\n                                (ss.motifs[1], ss.motifs[0]) + ds.motifs[1][1:])    # reverse strand\n\n            # case: ds reverse 5' sticky end binds to ss 5' sticky end\n            elif ds.end('r', '5') and ds.end('r', '5') == complement(ss.end('5'),self.motif_dict):\n\n                new_motifs = ((ss.motifs[0], ss.motifs[1]) + ds.motifs[0][1:],      # forward strand\n                                (None,) + ds.motifs[1])                             # reverse strand\n\n            else:\n                return Oligo(None)\n\n            return Oligo(new_motifs)\n</code></pre>"},{"location":"simulation/","title":"Simulation Framework","text":"<p>The <code>Simulation</code> class in <code>simulations/simulation.py</code> orchestrates automated end-to-end DNA storage simulations. It executes the complete pipeline from file binarization through synthesis, storage, sequencing, and decoding, while collecting detailed metrics and logging results.</p>"},{"location":"simulation/#overview","title":"Overview","text":"<p>The simulation framework enables:</p> <ul> <li>Batch Processing: Run multiple parameter configurations in sequence</li> <li>Automated Logging: Comprehensive logs saved to <code>simulations/simlogs/</code></li> <li>Progress Tracking: Real-time progress bars via tqdm</li> <li>Error Handling: Graceful failure handling with detailed error logs</li> <li>Result Serialization: Results saved as pickle files for later analysis</li> <li>Reproducibility: Optional random seed control for deterministic simulations</li> </ul>"},{"location":"simulation/#architecture","title":"Architecture","text":""},{"location":"simulation/#pipeline-steps","title":"Pipeline Steps","text":"<p>The simulation executes all steps of the DNAbyte data storage pipeline controlled by a params object:</p> <p>Each step: - Logs start time, status, duration, and key metrics - Returns an <code>info</code> dictionary with step-specific results - Handles errors gracefully without crashing the entire simulation - Saves results for later analysis</p>"},{"location":"simulation/#basic-usage","title":"Basic Usage","text":""},{"location":"simulation/#simple-example","title":"Simple Example","text":"<pre><code>from dnabyte.params import Params\nfrom simulation import Simulation\n\n# Configure simulation parameters\nparams = Params(\n    name='my_simulation',\n    file_paths=['data.txt'],\n    encoding_method='max_density',\n    binarization_method='compressed',\n    synthesis_method='mesa',\n    mesa_synthesis_id=68,\n    storage_conditions='biogene',\n    years=10,\n    sequencing_method='mesa',\n    sequencing_mesa_id=68\n)\n\n# Run simulation\nsim = Simulation([params])\nresults = sim.run()\n\n# Access results\nprint(results)\n</code></pre>"},{"location":"simulation/#parameter-ranges","title":"Parameter Ranges","text":"<p>Run simulations across multiple parameter values:</p> <pre><code>from dnabyte.params import Params\nfrom simulation import Simulation\n\n# Create parameter range (varies storage duration)\nparams_list = Params.params_range(\n    name='storage_duration_test',\n    file_paths=['test.txt'],\n    encoding_method='max_density',\n    binarization_method='compressed',\n    storage_conditions='biogene',\n    years=[1, 10, 100, 1000],  # Creates 4 parameter sets\n    synthesis_method='mesa',\n    mesa_synthesis_id=68,\n    sequencing_method='iid',\n    iid_error_rate=0.01\n)\n\n# Run all simulations\nsim = Simulation(params_list)\nresults = sim.run()\n\n# Analyze results\nfor name, data in results.items():\n    if data['status'] == 'SUCCESS':\n        print(f\"{name}: Encoding took {data['step2']['duration']:.2f}s\")\n</code></pre>"},{"location":"simulation/#initialization","title":"Initialization","text":""},{"location":"simulation/#constructor","title":"Constructor","text":"<pre><code>Simulation(simulation_parameters, debug=False)\n</code></pre> <p>Parameters: - <code>simulation_parameters</code> (list): List of <code>Params</code> objects or single <code>Params</code> object - <code>debug</code> (bool): Enable debug mode (currently unused)</p> <p>Initialization actions: 1. Creates logger instance 2. Generates unique job identifier (timestamp: <code>YYYYMMDD_HHMMSS</code>) 3. Creates log file: <code>simulations/simlogs/job_{timestamp}.log</code> 4. Sets up log formatting</p>"},{"location":"simulation/#running-simulations","title":"Running Simulations","text":""},{"location":"simulation/#run-method","title":"run() Method","text":"<pre><code>results = sim.run(paralel=False)\n</code></pre> <p>Parameters: - <code>paralel</code> (bool): Enable parallel processing (not yet implemented)</p> <p>Returns: - <code>dict</code>: Nested dictionary with results for each parameter set</p> <p>Result Structure:</p> <pre><code>{\n    'simulation_name_1': {\n        'status': 'SUCCESS' or 'FAILURE',\n        'step1': {'duration': 0.05, 'length_of_bitsream': 2144},\n        'step2': {'duration': 0.67, 'barcode_length': 34, ...},\n        'step3': {'duration': 0.12, ...},\n        # ... more steps ...\n    },\n    'simulation_name_2': { ... }\n}\n</code></pre>"},{"location":"simulation/#logging","title":"Logging","text":""},{"location":"simulation/#log-file-structure","title":"Log File Structure","text":"<pre><code>simulations/simlogs/job_20251211_163000.log\n</code></pre> <p>Log Format:</p> <pre><code>2025-12-11 16:30:00,123 - INFO - SIMULATION SETTING: my_simulation\n2025-12-11 16:30:00,124 - INFO - Params:\n  name: my_simulation\n  file_paths: ['test.txt']\n  ...\n2025-12-11 16:30:00,125 - INFO - STEP01: BINARIZE DATA\n2025-12-11 16:30:00,130 - INFO - STATUS: SUCCESS\n2025-12-11 16:30:00,130 - INFO - DURATION: 0.00 seconds\n</code></pre>"},{"location":"simulation/#log-levels","title":"Log Levels","text":"<ul> <li>INFO: Step execution, metrics, success messages</li> <li>ERROR: Failures, exceptions, error traces</li> </ul>"},{"location":"simulation/#result-serialization","title":"Result Serialization","text":"<p>Results are automatically saved as pickle files:</p> <pre><code>simulations/simlogs/res_20251211_163000.pickle\n</code></pre>"},{"location":"simulation/#loading-results","title":"Loading Results","text":"<pre><code>import pickle\n\nwith open('simulations/simlogs/res_20251211_163000.pickle', 'rb') as f:\n    results = pickle.load(f)\n\n# Analyze results\nfor name, data in results.items():\n    if data['status'] == 'SUCCESS':\n        total_time = sum(\n            step['duration'] \n            for step in data.values() \n            if isinstance(step, dict) and 'duration' in step\n        )\n        print(f\"{name}: Total time = {total_time:.2f}s\")\n</code></pre>"},{"location":"simulation/#error-handling","title":"Error Handling","text":""},{"location":"simulation/#graceful-failures","title":"Graceful Failures","text":"<p>Each step has independent error handling:</p> <pre><code>try:\n    # Execute step\n    data_enc, info = coder.encode(binary_code)\nexcept Exception as e:\n    self.simlogger.info('STATUS: ERROR')\n    self.simlogger.error('TYPE: %s', str(e))\n    self.simlogger.error(traceback.format_exc())\n    results[name]['status'] = 'FAILURE'\n    continue  # Skip to next parameter set\n</code></pre> <p>Behavior: - Individual step failures don't crash the simulation - Error logged with full traceback - Simulation continues with next parameter set - Failed simulations marked with <code>status: 'FAILURE'</code></p>"},{"location":"simulation/#progress-tracking","title":"Progress Tracking","text":"<p>Real-time progress bar using tqdm:</p> <pre><code>Simulation Progress: 45%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588      | 45/100 [02:15&lt;02:45,  3.05param/s]\n</code></pre> <p>Shows: - Percentage complete - Current/total parameter sets - Elapsed time - Estimated time remaining - Processing rate (params/second)</p>"},{"location":"simulation/#reproducibility","title":"Reproducibility","text":""},{"location":"simulation/#random-seed-control","title":"Random Seed Control","text":"<pre><code>params = Params(\n    name='reproducible_test',\n    seed=42,  # Set random seed\n    file_paths=['test.txt'],\n    # ... other params ...\n)\n\nsim = Simulation([params])\nresults = sim.run()\n</code></pre> <p>Behavior: - If <code>seed</code> is provided, sets <code>random.seed(params.seed + counter)</code> - Ensures deterministic behavior for stochastic steps - Different counter for each parameter set in batch</p>"},{"location":"simulation/#complete-example-success-rate-analysis","title":"Complete Example: Success Rate Analysis","text":"<pre><code>from dnabyte.params import Params\nfrom simulation import Simulation\n\n# Test error correction limits\nparams_list = Params.params_range(\n    name='success_rate_analysis',\n    file_paths=['test.txt'],\n    encoding_method='max_density',\n    binarization_method='compressed',\n    outer_error_correction='reedsolomon',\n    reed_solo_percentage=0.8,\n    synthesis_method='mesa',\n    mesa_synthesis_id=68,\n    storage_conditions='biogene',\n    years=[1, 10, 100, 1000, 10000],  # Vary storage duration\n    sequencing_method='iid',\n    iid_error_rate=0.01,\n    seed=42\n)\n\n# Run 100 repeats for each year value\nall_params = []\nfor _ in range(100):\n    all_params.extend(params_list)\n\nsim = Simulation(all_params)\nresults = sim.run()\n\n# Calculate success rates\nfrom collections import defaultdict\nsuccess_counts = defaultdict(lambda: {'success': 0, 'failure': 0})\n\nfor name, data in results.items():\n    # Extract year from params (would need to track this)\n    year = ...  # Extract from name or params\n    if data['status'] == 'SUCCESS':\n        success_counts[year]['success'] += 1\n    else:\n        success_counts[year]['failure'] += 1\n\n# Plot success rates\nfor year, counts in success_counts.items():\n    rate = counts['success'] / (counts['success'] + counts['failure'])\n    print(f\"Year {year}: Success rate = {rate:.2%}\")\n</code></pre>"},{"location":"simulation/#planned-features","title":"Planned Features","text":"<ul> <li>Parallel Processing: Multi-threaded/multi-process execution</li> <li>Checkpointing: Resume interrupted simulations</li> <li>CLI Integration: Command-line interface for simulations</li> <li>Real-time Monitoring: Web dashboard for live progress</li> <li>Custom Callbacks: User-defined functions at each step</li> </ul>"},{"location":"simulation/#tips-and-best-practices","title":"Tips and Best Practices","text":"<ol> <li>Start Small: Test with small files before large-scale simulations</li> <li>Use Seeds: Set <code>seed</code> parameter for reproducible results</li> <li>Monitor Logs: Check log files for detailed error information</li> <li>Batch Wisely: Balance batch size with memory constraints</li> <li>Save Results: Always check that pickle files are saved successfully</li> <li>Clean Up: Remove test files after simulations complete</li> </ol>"},{"location":"simulation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"simulation/#common-issues","title":"Common Issues","text":"<p>\"FileNotFoundError: No such file or directory\" - Ensure file paths are relative to project root - Check that input files exist before running</p> <p>\"MMseqs2 not installed\" - Required for <code>linear_binom</code> and <code>poly_binom</code> encodings - Install: <code>brew install mmseqs2</code> (macOS) or equivalent</p> <p>\"Decoding failed - error correction could not recover data\" - Expected behavior when errors exceed correction capacity - Increase <code>reed_solo_percentage</code> or reduce error rates</p> <p>Memory errors with large files - Process files in smaller batches - Reduce <code>file_paths</code> list size</p>"},{"location":"simulation/#contact","title":"Contact","text":"<p>For questions, issues, or contributions, open a GitHub issue or contact the maintainers.</p>"},{"location":"usage/","title":"Pipeline Steps","text":""},{"location":"usage/#step-0-parameter-configuration-params-class","title":"Step 0: Parameter Configuration (<code>Params</code> class)","text":"<p>The <code>Params</code> class encapsulates all configuration parameters required to simulate a full DNA data storage workflow. The parameters can be grouped into the steps of the pipeline they concern:</p>"},{"location":"usage/#parameter-groups","title":"Parameter Groups","text":"<ul> <li>File &amp; Identification: <code>name</code>, <code>file_paths</code>, <code>seed</code>, <code>debug</code></li> <li>Binarization: <code>binarization_method</code>, <code>compression_level</code></li> <li>Encoding: <code>encoding_method</code>, <code>assembly_structure</code>, <code>library_name</code>, <code>codeword_length</code>, <code>dna_barcode_length</code>, <code>codeword_maxlength_positions</code>, <code>percent_of_symbols</code>, <code>sigma_amount</code></li> <li>Error Correction: <code>inner_error_correction</code>, <code>outer_error_correction</code>, <code>reed_solo_percentage</code>, <code>ltcode_header</code>, <code>index_carry_length</code></li> <li>Synthesis: <code>synthesis_method</code>, <code>mesa_synthesis_id</code>, <code>mean</code>, <code>vol</code>, <code>std_dev</code>, <code>hybridisation_steps</code></li> <li>Storage: <code>years</code>, <code>storage_conditions</code></li> <li>Sequencing: <code>sequencing_method</code>, <code>sequencing_mesa_id</code>, <code>iid_error_rate</code></li> </ul> <p>More details about the parameters will be provided in the respective sections. </p>"},{"location":"usage/#example-usage","title":"Example Usage","text":"<pre><code>from dnabyte.params import Params\n\nparams = Params(\n    name=\"test1\",\n    file_paths=['my_file.txt'],\n    binarization_method='compressed',\n    encoding_method='max_density',\n    outer_error_correction='reedsolomon',\n    reed_solo_percentage=0.8,\n    dna_barcode_length=34,\n    codeword_length=501\n)\n</code></pre>"},{"location":"usage/#creating-parameter-ranges","title":"Creating Parameter Ranges","text":"<p>Create multiple parameter sets by varying one parameter:</p> <pre><code>params_list = Params.params_range(\n    name='storage_duration_test',\n    file_paths=['test.txt'],\n    encoding_method='max_density',\n    binarization_method='compressed',\n    storage_conditions='biogene',\n    years=[1, 10, 100, 1000]  # Creates 4 Params objects\n)\n# Returns a list of 4 Params objects, one for each year value\n</code></pre>"},{"location":"usage/#step-1-binarize-and-compress-data","title":"Step 1: Binarize and Compress Data","text":"<p>To initiate the binarization process, create a <code>Data</code> object with a list of file paths, then use <code>Binarize</code> to convert it to binary.</p> <pre><code>from dnabyte.data_classes.base import Data\nfrom dnabyte.binarize import Binarize\n\n# Create data object\ndata_obj = Data(file_paths=[\"mi_dna_disc_logo.png\"])\n\n# Configure and run binarization\nparams = Params(binarization_method='compressed', compression_level=9)\nbinarizer = Binarize(params)\nbinary_code = binarizer.binarize(data_obj)\n\nprint(f\"Binary length: {len(binary_code.data)} bits\")\nprint(f\"Binary data: {binary_code.data[:50]}...\")\n</code></pre> <p>The <code>Binarize</code> class compresses all input files into a temporary <code>.tar.gz</code> archive (when using <code>compressed</code> method), reads it as a binary stream, and converts it into a bitstring. This binary string is stored in <code>binary_code.data</code>. The temporary archive is deleted after use.</p>"},{"location":"usage/#binarization-methods","title":"Binarization Methods","text":"<ul> <li><code>'compressed'</code>: Tar+gzip compression (recommended, requires <code>compression_level</code> parameter)</li> <li><code>'text'</code>: Plain text encoding</li> <li><code>'default'</code>: No compression</li> </ul>"},{"location":"usage/#binarycode-class","title":"BinaryCode Class","text":"<p>The result is a <code>BinaryCode</code> object containing: - <code>data</code> (str): Binary string (e.g., \"10010101...\") - <code>file_paths</code> (list): Original file paths</p>"},{"location":"usage/#step-2-encode-data","title":"Step 2: Encode Data","text":"<p>The encoding process transforms binary data into DNA sequences with optional error correction.</p>"},{"location":"usage/#usage","title":"Usage","text":"<pre><code>from dnabyte.encode import Encode\n\nencoder = Encode(params)\nnucleobase_code, info = encoder.encode(binary_code)\n\nprint(f\"Number of codewords: {len(nucleobase_code.data)}\")\nprint(f\"Barcode length: {info['barcode_length']}\")\n</code></pre>"},{"location":"usage/#encoding-methods","title":"Encoding Methods","text":"Encoding Method Assembly Structure Description <code>max_density</code> <code>synthesis</code> Maximum information density encoding <code>no_homopolymer</code> <code>synthesis</code> Homopolymer-free encoding <code>linear_chain</code> <code>linear_assembly</code> Linear chain assembly <code>linear_binom</code> <code>linear_assembly</code> Binomial linear assembly <code>poly_chain</code> <code>polymerase_assembly</code> Polymerase chain assembly <code>poly_binom</code> <code>polymerase_assembly</code> Binomial polymerase assembly"},{"location":"usage/#error-correction-parameters","title":"Error Correction Parameters","text":"Parameter Description <code>inner_error_correction</code> Selects inner-layer error correction: <code>'ltcode'</code> or <code>None</code> <code>ltcode_header</code> Number of bits used for Luby Transform code headers <code>percent_of_symbols</code> Percentage of symbols included in each encoded LT packet <code>index_carry_length</code> Number of bits used to carry the LT-code packet index <code>outer_error_correction</code> Selects outer-layer error correction: <code>'reedsolomon'</code> or <code>None</code> <code>reed_solo_percentage</code> Redundancy percentage for Reed-Solomon coding (0.0-1.0) <p>Example with error correction:</p> <pre><code>params = Params(\n    file_paths=['data.txt'],\n    encoding_method='max_density',\n    binarization_method='compressed',\n    codeword_length=501,\n    dna_barcode_length=34,\n    inner_error_correction='ltcode',\n    ltcode_header=34,\n    percent_of_symbols=2,\n    index_carry_length=34,\n    outer_error_correction='reedsolomon',\n    reed_solo_percentage=0.8  # 80% redundancy\n)\n</code></pre> <p>These error correction methods are commonly used for synthesis-based methods, where the information lies in the sequence of nucleotides. They can also be used for assembly-based methods, where the information lies in the sequence of motifs (short nucleotide sequences). Note that assembly-based methods exhibit implicit error correction from their restricted sequence space.</p>"},{"location":"usage/#nucleobasecode-class","title":"NucleobaseCode Class","text":"<p>The result is a <code>NucleobaseCode</code> object. The structure of <code>data</code> depends on the encoding method:</p> <ul> <li>Synthesis methods (<code>max_density</code>, <code>no_homopolymer</code>): <code>data</code> is a list of DNA strings</li> <li>Assembly methods (<code>linear_chain</code>, <code>poly_chain</code>, etc.): <code>data</code> is nested lists of library elements</li> </ul>"},{"location":"usage/#step-3-simulate-synthesis","title":"Step 3: Simulate Synthesis","text":"<p>Simulates the synthesis process of converting digital data into DNA oligonucleotides. There are two different synthesis strategies determined by the <code>synthesis_method</code> parameter:</p> <ul> <li><code>'mesa'</code>: Nucleotide-wise chemical synthesis based on the MESA model</li> <li><code>'assembly'</code>: Synthesis by ligating short oligos from a library (hybridization simulation) </li> </ul>"},{"location":"usage/#usage_1","title":"Usage","text":"<pre><code>from dnabyte.synthesize import SimulateSynthesis\n\nsynthesizer = SimulateSynthesis(params)\nsynthesized_dna, info = synthesizer.simulate(nucleobase_code)\n\nprint(f\"Number of sequences: {len(synthesized_dna.data)}\")\n</code></pre>"},{"location":"usage/#mesa-synthesis-parameters","title":"MESA Synthesis Parameters","text":"Synthesis Approach Method Method ID Column synthesized oligos MutS <code>68</code> Consensus shuffle <code>69</code> ErrASE <code>6</code> No error correction <code>71</code> Microarray based oligo pools Oligo hybridization based error correction <code>4</code> High-temperature ligation/hybridization based <code>5</code> ErrASE <code>3</code> Nuclease-based <code>7</code> NGS-based <code>70</code> No error correction <code>71</code>"},{"location":"usage/#assembly-synthesis-parameters","title":"Assembly Synthesis Parameters","text":"<p>For assembly-based approaches (<code>synthesis_method='assembly'</code>), the following parameters must be provided:</p> Parameter Description <code>mean</code> Mean number of copies of an oligonucleotide <code>std_dev</code> Standard deviation of copy numbers <code>vol</code> Volume of the solution (in liters) <code>hybridisation_steps</code> Number of random hybridization steps (proxy for reaction time) <p>Example:</p> <pre><code>from scipy.constants import Avogadro\n\nparams = Params(\n    synthesis_method='mesa',\n    mesa_synthesis_id=68,\n    mean=20,\n    vol=1000000 / Avogadro,\n    std_dev=1,\n    hybridisation_steps=10000\n)\n</code></pre>"},{"location":"usage/#insilicodna-class","title":"InSilicoDNA Class","text":"<p>The result is an <code>InSilicoDNA</code> object containing: - <code>data</code> (list): List of DNA sequence strings - Methods for statistics and string representation</p>"},{"location":"usage/#reference","title":"Reference","text":"<p>[1] Schwarz, Michael, et al. \"MESA: automated assessment of synthetic DNA fragments and simulation of DNA synthesis, storage, sequencing and PCR errors.\" Bioinformatics 36.11 (2020): 3322-3326.</p>"},{"location":"usage/#step-4-simulate-storage","title":"Step 4: Simulate Storage","text":"<p>The <code>SimulateStorage</code> class models the long-term degradation of DNA sequences stored under various environmental conditions. DNA degradation is modeled probabilistically based on empirical decay rates under three conditions:</p> <ul> <li><code>'biogene'</code>: 1\u00d710\u207b\u2077 per nucleotide per year (Biogene capsule storage)</li> <li><code>'permafrost'</code>: 5.5\u00d710\u207b\u2076 per nucleotide per year  </li> <li><code>'roomtemperature'</code>: approximated half-life of 521 years (decay rate \u2248 0.00133)</li> <li><code>'random'</code>: Custom decay for testing</li> </ul>"},{"location":"usage/#usage_2","title":"Usage","text":"<pre><code>from dnabyte.store import SimulateStorage\n\nstorage = SimulateStorage(params)\nstored_dna, info = storage.simulate(synthesized_dna)\n\nprint(f\"Strand breaks: {info['number_of_strand_breaks']}\")\n</code></pre>"},{"location":"usage/#storage-parameters","title":"Storage Parameters","text":"Parameter Type Description <code>years</code> <code>int</code> Number of years to simulate storage. Use <code>0</code> to disable simulation. <code>storage_conditions</code> <code>str</code> One of <code>'permafrost'</code>, <code>'roomtemperature'</code>, <code>'biogene'</code>, or <code>'random'</code>. <p>The <code>'random'</code> mode allows base substitutions to simulate artificial mutation rates.</p>"},{"location":"usage/#return-values","title":"Return Values","text":"<ul> <li><code>InSilicoDNA</code> object (filtered or mutated sequences)</li> <li><code>info</code> dictionary containing:</li> <li><code>number_of_strand_breaks</code>: Number of sequences degraded</li> </ul>"},{"location":"usage/#references","title":"References","text":"<p>[1] Allentoft, M. E. et al. The half-life of DNA in bone: measuring decay kinetics in 158 dated fossils. Proc. R. Soc. B 279, 4724\u20134733 (2012). [2] Coudy, D. et al. Long term conservation of DNA at ambient temperature: Implications for DNA data storage. PLoS One 16.11 (2021): e0259868.</p>"},{"location":"usage/#step-5-simulate-sequencing","title":"Step 5: Simulate Sequencing","text":"<p>The <code>SimulateSequencing</code> class models the sequencing process by applying sequencing-specific error profiles to stored DNA oligonucleotides.</p>"},{"location":"usage/#usage_3","title":"Usage","text":"<pre><code>from dnabyte.sequence import SimulateSequencing\n\nsequencer = SimulateSequencing(params)\nsequenced_dna, info = sequencer.simulate(stored_dna)\n\nprint(f\"Errors introduced: {len(info)}\")\n</code></pre>"},{"location":"usage/#sequencing-methods","title":"Sequencing Methods","text":"Sequencing Method ID/Parameter Description <code>None</code> - No sequencing simulation is performed. <code>'iid'</code> <code>iid_error_rate</code> Independent and identically distributed error model (specify custom rate). <code>'mesa'</code> <code>35</code> Illumina: Single End <code>'mesa'</code> <code>36</code> Illumina: Paired End <code>'mesa'</code> <code>39</code> Nanopore: 1D <code>'mesa'</code> <code>40</code> Nanopore: 2D <code>'mesa'</code> <code>37</code> PacBio: Subread <code>'mesa'</code> <code>38</code> PacBio: CCS"},{"location":"usage/#examples","title":"Examples","text":"<pre><code># MESA sequencing with Illumina\nparams = Params(\n    sequencing_method='mesa',\n    sequencing_mesa_id=35  # Illumina Single End\n)\n\n# IID sequencing with custom error rate\nparams = Params(\n    sequencing_method='iid',\n    iid_error_rate=0.01  # 1% error rate\n)\n</code></pre>"},{"location":"usage/#return-values_1","title":"Return Values","text":"<ul> <li><code>InSilicoDNA</code> object with sequencing errors</li> <li><code>info</code> list containing error information</li> </ul>"},{"location":"usage/#step-6-process-data","title":"Step 6: Process Data","text":"<p>Align and prepare sequences for decoding. This step processes sequenced reads to prepare them for error correction and decoding.</p>"},{"location":"usage/#usage_4","title":"Usage","text":"<pre><code># Process sequenced data\nprocessed_code, info = encoder.process(sequenced_dna)\n\nprint(f\"Processed {len(processed_code.data)} codewords\")\n</code></pre> <p>Note: For assembly methods requiring sequence alignment (<code>linear_binom</code>, <code>poly_binom</code>), this step requires MMseqs2 to be installed on your system.</p>"},{"location":"usage/#return-values_2","title":"Return Values","text":"<ul> <li><code>NucleobaseCode</code> object ready for decoding</li> <li><code>info</code> dictionary with processing metrics</li> </ul>"},{"location":"usage/#step-7-decode-data","title":"Step 7: Decode Data","text":"<p>Decode DNA sequences back to binary with error correction.</p>"},{"location":"usage/#usage_5","title":"Usage","text":"<pre><code>decoded_binary, valid, info = coder.decode(processed_code)\n\nif valid:\n    print(\"Decoding successful!\")\n    print(f\"Recovered {len(decoded_binary.data)} bits\")\nelse:\n    print(\"Decoding failed - error correction could not recover data\")\n</code></pre>"},{"location":"usage/#return-values_3","title":"Return Values","text":"<ul> <li><code>BinaryCode</code> object with recovered binary data</li> <li><code>valid</code> (bool): <code>True</code> if error correction successfully recovered original data</li> <li><code>info</code> dictionary with decoding metrics</li> </ul> <p>The <code>valid</code> flag indicates whether the decoded data matches the original after error correction. If too many errors were introduced during synthesis/storage/sequencing, <code>valid</code> will be <code>False</code>.</p>"},{"location":"usage/#step-8-restore-files","title":"Step 8: Restore Files","text":"<p>Convert binary back to original files.</p>"},{"location":"usage/#usage_6","title":"Usage","text":"<pre><code>if valid:\n    restored_data, info = binarizer.debinarize(decoded_binary)\n    print(f\"Files restored: {restored_data.file_paths}\")\n</code></pre>"},{"location":"usage/#return-values_4","title":"Return Values","text":"<ul> <li><code>Data</code> object with restored files</li> <li><code>info</code> dictionary with restoration metrics</li> </ul> <p>The files are restored to their original format and can be accessed from the file system.</p>"},{"location":"usage/#minimal-example-no-error-channels","title":"Minimal Example (No Error Channels)","text":"<pre><code>from dnabyte.params import Params\nfrom dnabyte.data_classes.base import Data\nfrom dnabyte.binarize import Binarize\nfrom dnabyte.encode import Encode\n\nparams = Params(\n    file_paths=['test.txt'],\n    encoding_method='max_density',\n    binarization_method='compressed',\n    synthesis_method=None,\n    storage_conditions=None,\n    sequencing_method=None\n)\n\ndata = Data(file_paths=['test.txt'])\nbinarizer = Binarize(params)\nencoder = Encode(params)\n\nbinary = binarizer.binarize(data)\nencoded, _ = encoder.encode(binary)\ndecoded, valid, _ = encoder.decode(encoded)\n\nif valid:\n    restored, _ = binarizer.debinarize(decoded)\n    print(\"Success!\")\n</code></pre>"},{"location":"usage/#additional-references","title":"Additional References","text":"<p>[1] Schwarz, M., et al. \"MESA: automated assessment of synthetic DNA fragments and simulation of DNA synthesis, storage, sequencing and PCR errors.\" Bioinformatics 36.11 (2020): 3322-3326.</p> <p>[2] Allentoft, M.E., et al. \"The half-life of DNA in bone: measuring decay kinetics in 158 dated fossils.\" Proc. R. Soc. B 279 (2012): 4724\u20134733.</p> <p>[3] Coudy, D., et al. \"Long term conservation of DNA at ambient temperature: Implications for DNA data storage.\" PLoS One 16.11 (2021): e0259868.</p>"}]}