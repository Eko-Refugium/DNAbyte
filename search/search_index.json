{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>DNAbyte is a comprehensive toolkit for DNA data storage. It provides a framework for the simulation and analysis of the complete end-to-end pipeline of DNA data storage, including:</p> <ol> <li>File Binarization: Converts input files into a compressed binary format suitable for encoding.</li> <li>Encoding: Translates binary data into DNA sequences using various encoding strategies and error correction schemes.</li> <li>Simulation: Provides configurable error channels for (i) DNA synthesis, (ii) storage, and sequencing.</li> <li>Decoding: Decodes and error-corrects the DNA back to binary and restores the original file.</li> </ol> <p></p>"},{"location":"#structure-of-this-documentation","title":"Structure of this Documentation","text":"<ul> <li> <p>The Usage section provides example code for running an end-to-end data storage pipeline, including detailed explanations of all configurable parameters.</p> </li> <li> <p>For step-by-step guidance on executing simulations, refer to the Simulation section.</p> </li> <li> <p>To gain a deeper understanding of the core concepts\u2014especially encoding techniques\u2014see the Concepts section.</p> </li> <li> <p>The Reference section offers comprehensive documentation for all functions and classes within the DNAbyte module.</p> </li> </ul> <p>Eko Refugium is part of the MI-DNA DISC consortium. (www.midnadisc.eu) MI-DNA DISC was funded by the EU Commission in the framework of the Horizon Europe \u2013 EIC Pathfinder Challenges programme. Grant Agreement 101115215 </p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#data-structures","title":"Data structures","text":""},{"location":"reference/#dnads","title":"DNADS","text":"<p>DNADS is the base class for all data types in the MI-DNA-DISC project.</p> <p>It can be instantiated   - with a list of absolute paths to files or, alternatively  - with a path to a folder using the alternative constructor from_folder.</p> <p>:param file_paths: A list of absolute paths to files.</p> Source code in <code>dnabyte/data.py</code> <pre><code>class DNADS:\n    \"\"\"\n    DNADS is the base class for all data types in the MI-DNA-DISC project.\n\n    It can be instantiated \n     - with a list of absolute paths to files or, alternatively\n     - with a path to a folder using the alternative constructor from_folder.\n\n    :param file_paths: A list of absolute paths to files.    \n    \"\"\"\n    def __init__(self, file_paths):\n        for file_path in file_paths:\n            if not os.path.isfile(file_path):\n                raise ValueError(f\"File path {file_path} does not point to an existing file.\")\n        self.file_paths = file_paths\n        #self.size = self.calculate_total_bytes()\n\n    @classmethod\n    def from_folder(cls, folder_path):\n        if not os.path.isdir(folder_path):\n            raise ValueError(f\"Folder path {folder_path} does not point to an existing directory.\")\n        file_paths = [os.path.join(folder_path, filename) for filename in os.listdir(folder_path)]\n        return cls(file_paths)\n\n    def calculate_total_bytes(self):\n        total_bytes = 0\n        for file_path in self.file_paths:\n            total_bytes += os.path.getsize(file_path)\n        return total_bytes\n\n    def __str__(self):\n        output = \"Type: \" + str(type(self)) + \"\\n\"\n        #output += \"Bytes:\" + str(self.size) + \"\\n\"\n        output += \"File paths: \" + str(self.file_paths) + \"\\n\"\n        return output\n\n    def binarize(self):\n        \"\"\"\n        Converts the files in the DNADS object to a binary sequence.\n\n        :return: A string of binary data.\n        \"\"\"\n        # Create a compressed tar archive file\n        folder_path = os.path.dirname(self.file_paths[0])\n        archive_name = folder_path + '/archive.tar.gz'\n\n        with tarfile.open(archive_name, 'w:gz') as archive:\n            for file_path in self.file_paths:\n                archive.add(file_path)\n\n        size = os.path.getsize(archive_name)\n\n        with open(archive_name, 'rb') as file:\n            binary_data = file.read()\n            binary_sequence = ''.join(format(byte, '08b') for byte in binary_data)\n\n        os.remove(archive_name)\n\n        obj = RawData(self)\n        obj.size = size\n        obj.file_paths = self.file_paths\n        obj.data = binary_sequence\n        obj.length = len(binary_sequence)\n\n        return obj\n</code></pre>"},{"location":"reference/#dnabyte.data.DNADS.binarize","title":"<code>binarize()</code>","text":"<p>Converts the files in the DNADS object to a binary sequence.</p> <p>:return: A string of binary data.</p> Source code in <code>dnabyte/data.py</code> <pre><code>def binarize(self):\n    \"\"\"\n    Converts the files in the DNADS object to a binary sequence.\n\n    :return: A string of binary data.\n    \"\"\"\n    # Create a compressed tar archive file\n    folder_path = os.path.dirname(self.file_paths[0])\n    archive_name = folder_path + '/archive.tar.gz'\n\n    with tarfile.open(archive_name, 'w:gz') as archive:\n        for file_path in self.file_paths:\n            archive.add(file_path)\n\n    size = os.path.getsize(archive_name)\n\n    with open(archive_name, 'rb') as file:\n        binary_data = file.read()\n        binary_sequence = ''.join(format(byte, '08b') for byte in binary_data)\n\n    os.remove(archive_name)\n\n    obj = RawData(self)\n    obj.size = size\n    obj.file_paths = self.file_paths\n    obj.data = binary_sequence\n    obj.length = len(binary_sequence)\n\n    return obj\n</code></pre>"},{"location":"reference/#rawdata","title":"RawData","text":"<p>               Bases: <code>DNADS</code></p> <p>RawData is a subclass of DNADS.</p> <p>It consists of a compressed bitstream of the files in the DNADS object. For testing purposes, the RawData object can also directly be created from a bitstream.</p> <p>:param dnads: A DNADS object.</p> Source code in <code>dnabyte/data.py</code> <pre><code>class RawData(DNADS):\n    \"\"\"\n    RawData is a subclass of DNADS.\n\n    It consists of a compressed bitstream of the files in the DNADS object. For testing purposes, the RawData object can also directly be created from a bitstream.\n\n    :param dnads: A DNADS object.\n    \"\"\"\n    def init(self, bitstream):\n        \"\"\"\n        Creates a RawData object from a bitstream.\n\n        :param bitstream: A string of binary data.\n        \"\"\"\n        self.file_paths = None\n        instance = self.__new__(self)\n        instance.data = bitstream\n        instance.length = len(bitstream)\n        instance.size = len(bitstream) // 8  # Size in bytes\n        instance.file_paths = None\n\n        return instance\n\n    def __str__(self):\n        output = \"DATA: \" + str(self.data)[:50] + \"...\\n\"\n\n        # output = \"Type: \" + str(type(self)) + \"\\n\"\n        # output += \"Bytes:\" + str(self.calculate_total_bytes()) + \"\\n\"\n        # output += \"DATA: \" + str(self.data)[:200] + \"...\\n\"\n        return output\n</code></pre>"},{"location":"reference/#dnabyte.data.RawData.init","title":"<code>init(bitstream)</code>","text":"<p>Creates a RawData object from a bitstream.</p> <p>:param bitstream: A string of binary data.</p> Source code in <code>dnabyte/data.py</code> <pre><code>def init(self, bitstream):\n    \"\"\"\n    Creates a RawData object from a bitstream.\n\n    :param bitstream: A string of binary data.\n    \"\"\"\n    self.file_paths = None\n    instance = self.__new__(self)\n    instance.data = bitstream\n    instance.length = len(bitstream)\n    instance.size = len(bitstream) // 8  # Size in bytes\n    instance.file_paths = None\n\n    return instance\n</code></pre>"},{"location":"reference/#encodeddata","title":"EncodedData","text":"<p>               Bases: <code>DNADS</code></p> <p>EncodedData is a subclass of DNADS.</p> <p>Its main attribute is the data object, which consists of a multi-leveled list. At the highest level, data consists of a list of codewords, there is one list for every codeword in the data object. At the lowest level there are lists of motifs or nucleotides, that are to be hybridised in a single pool. The list structure represents the hierarchical structure of the pooling process. </p> <p>:param raw_data: A RawData object. :param encoding_scheme: An EncodingScheme object.</p> Source code in <code>dnabyte/data.py</code> <pre><code>class EncodedData(DNADS):\n    \"\"\"\n    EncodedData is a subclass of DNADS.\n\n    Its main attribute is the data object, which consists of a multi-leveled list. At the highest level, data consists of a list of codewords, there is one list for every codeword in the data object. At the lowest level there are lists of motifs or nucleotides, that are to be hybridised in a single pool. The list structure represents the hierarchical structure of the pooling process. \n\n    :param raw_data: A RawData object.\n    :param encoding_scheme: An EncodingScheme object.\n    \"\"\"\n    #TODO: make it an actual subclass of DNADS \n    def __init__(self, raw_data, **kwargs):\n        #self.file_paths = raw_data.file_paths\n        #self.size = raw_data.size\n        self.data = raw_data\n        if \"file_paths\" in kwargs:\n            self.file_paths = kwargs['file_paths']\n\n\n    def __str__(self):\n        output = \"DATA: \" + str(self.data)[:50] + \"...\\n\"\n\n        # output = \"Type: \" + str(type(self)) + \"\\n\"\n        # #output += \"Bytes:\" + str(self.calculate_total_bytes()) + \"\\n\"\n        # output += \"Number of Codewords : \" + str(len(self.data)) + \"\\n\"\n        # output += \"DATA: \" + str(self.data)[:200] + \"...\\n\"\n        return output\n</code></pre>"},{"location":"reference/#assembleddata","title":"AssembledData","text":"<p>               Bases: <code>DNADS</code></p> <p>AssembledData is a subclass of DNADS.</p> <p>It consists of a list of codewords generated from the list of codewords of the EncodedData object. This step simulates the process of synthesizing DNA from the codewords. In this process the codewords are generated in stochastic number of copies and errors are introduced.</p> <p>:param encoded_data: An EncodedData object. :param synthesis_simulator: A SynthesisSimulator object.</p> Source code in <code>dnabyte/data.py</code> <pre><code>class AssembledData(DNADS):\n    \"\"\"\n    AssembledData is a subclass of DNADS.\n\n    It consists of a list of codewords generated from the list of codewords of the EncodedData object. This step simulates the process of synthesizing DNA from the codewords. In this process the codewords are generated in stochastic number of copies and errors are introduced.\n\n    :param encoded_data: An EncodedData object.\n    :param synthesis_simulator: A SynthesisSimulator object.\n    \"\"\"\n\n    def __init__(self, encoded_data=None):\n        if encoded_data is not None and isinstance(encoded_data, EncodedData):\n            self.file_paths = encoded_data.file_paths\n            #self.size = encoded_data.size\n\n        self.data = None        \n\n    def __str__(self):\n        output = \"DATA: \" + str(self.data)[:50] + \"...\\n\"\n\n        # output = \"\\n\" + \"Type: \" + str(type(self)) + \"\\n\"\n        # #output += \"Bytes:\" + str(self.calculate_total_bytes()) + \"\\n\"\n        # output += \"DATA: \" + str(self.data)[:200] + \"...\\n\"\n        return output\n</code></pre>"},{"location":"reference/#storedddata","title":"StoreddData","text":"<p>               Bases: <code>DNADS</code></p> <p>StoredData is a subclass of DNADS. It consists of a list of stored codewords generated from the list of synthesized codewords of the SynthesizedData object.</p> <p>:param synthesized_data: A SynthesizedData object. :param storage_simulator: A StorageSimulator object.</p> Source code in <code>dnabyte/data.py</code> <pre><code>class StoredData(DNADS):\n    \"\"\"\n    StoredData is a subclass of DNADS. It consists of a list of stored codewords generated from the list of synthesized codewords of the SynthesizedData object.\n\n    :param synthesized_data: A SynthesizedData object.\n    :param storage_simulator: A StorageSimulator object.\n    \"\"\"\n    def __init__(self, assembled_data=None):\n        if assembled_data is not None and isinstance(assembled_data, AssembledData):                                        \n            self.file_paths = assembled_data.file_paths\n            self.size = assembled_data.size\n            self.data = assembled_data.data\n            self.scale = assembled_data.scale\n        else:\n            self.file_paths = None\n            self.size = None\n            self.data = assembled_data\n            self.scale = 1\n\n\n    def __str__(self):\n        output = \"DATA: \" + str(self.data)[:50] + \"...\\n\"\n\n        # output = \"\\n\" + \"Type: \" + str(type(self)) + \"\\n\"\n        # if self.file_paths is not None:\n        #     output += \"File paths: \" + str(self.file_paths) + \"\\n\"\n        #     output += \"Bytes:\" + str(self.calculate_total_bytes()) + \"\\n\"\n        # output += \"DATA: \" + str(self.data)[:200] + \"...\\n\"\n        return output\n</code></pre>"},{"location":"reference/#sequenceddata","title":"SequencedData","text":"<p>               Bases: <code>DNADS</code></p> <p>SequencedData is a subclass of DNADS. It consists of a list of codewords generated from the list of stored codewords of the StoredData object.</p> <p>:param data: A StoredData object. :param sequencing_simulator: A SequencingSimulator object.</p> Source code in <code>dnabyte/data.py</code> <pre><code>class SequencedData(DNADS):\n    \"\"\"\n    SequencedData is a subclass of DNADS. It consists of a list of codewords generated from the list of stored codewords of the StoredData object.\n\n    :param data: A StoredData object.\n    :param sequencing_simulator: A SequencingSimulator object.\n    \"\"\"\n    def __init__(self, data):\n        if data is not None and isinstance(data, StoredData):\n            self.file_paths = data.file_paths\n            self.size = data.size\n            self.data = data.data\n            self.scale = data.scale\n        else:\n            self.file_paths = None\n            self.size = None\n            self.data = data\n            self.scale = 1\n\n\n    def __str__(self):\n        output = \"DATA: \" + str(self.data)[:50] + \"...\\n\"\n\n        # output = \"\\n\" + \"Type: \" + str(type(self)) + \"\\n\"\n        # if self.file_paths is not None:\n        #     output += \"File paths: \" + str(self.file_paths) + \"\\n\"\n        #     output += \"Bytes:\" + str(self.calculate_total_bytes()) + \"\\n\"\n        # output += \"DATA: \" + str(self.data)[:200] + \"...\\n\"\n        return output\n</code></pre>"},{"location":"reference/#correcteddata","title":"CorrectedData","text":"<p>               Bases: <code>DNADS</code></p> Source code in <code>dnabyte/data.py</code> <pre><code>class CorrectedData(DNADS):\n\n    def __init__(self, sequenced_data):\n        if sequenced_data is not None and isinstance(sequenced_data, SequencedData):\n            self.file_paths = sequenced_data.file_paths\n            self.size = sequenced_data.size\n            self.data = sequenced_data.data\n        else:\n            self.file_paths = None\n            self.size = None\n            self.data = sequenced_data\n\n    def __str__(self):\n        output = \"DATA: \" + str(self.data)[:50] + \"...\\n\"\n\n        # output = \"\\n\" + \"Type: \" + str(type(self)) + \"\\n\"\n        # if self.file_paths is not None:\n        #     output += \"File paths: \" + str(self.file_paths) + \"\\n\"\n        #     output += \"Bytes:\" + str(self.calculate_total_bytes()) + \"\\n\"\n        # output += \"DATA: \" + str(self.data)[:200] + \"...\\n\"\n        return output\n</code></pre>"},{"location":"reference/#decodeddata","title":"DecodedData","text":"<p>               Bases: <code>DNADS</code></p> <p>DecodedData is a subclass of DNADS. It consists of a bitstream created from the list of sequenced codewords of the SequencedData object.</p> <p>:param sequenced_data: A SequencedData object. :param encoding_scheme: An EncodingScheme object.</p> Source code in <code>dnabyte/data.py</code> <pre><code>class DecodedData(DNADS):\n    \"\"\"\n    DecodedData is a subclass of DNADS. It consists of a bitstream created from the list of sequenced codewords of the SequencedData object.\n\n    :param sequenced_data: A SequencedData object.\n    :param encoding_scheme: An EncodingScheme object.\n    \"\"\"\n    def __init__(self, sequenced_data):\n        self.file_paths = sequenced_data.file_paths\n        self.size = sequenced_data.size\n        self.data = None\n\n    def __str__(self):\n        output = \"DATA: \" + str(self.data)[:50] + \"...\\n\"\n\n        # output = \"\\n\" + \"Type: \" + str(type(self)) + \"\\n\"\n        # if self.file_paths is not None:\n        #     output += \"File paths: \" + str(self.file_paths) + \"\\n\"\n        #     output += \"Bytes:\" + str(self.calculate_total_bytes()) + \"\\n\"\n        # output += \"DATA: \" + str(self.data)[:200] + \"...\\n\"\n        return output\n</code></pre>"},{"location":"reference/#restoreddata","title":"RestoredData","text":"<p>RestoredData is a class that reconstructs the original files from a binary sequence.</p> <p>:param raw_data: A RawData object. :param output_folder: The folder where the restored files will be saved.</p> Source code in <code>dnabyte/data.py</code> <pre><code>class RestoredData:\n    \"\"\"\n    RestoredData is a class that reconstructs the original files from a binary sequence.\n\n    :param raw_data: A RawData object.\n    :param output_folder: The folder where the restored files will be saved.\n    \"\"\"\n    def __init__(self, raw_data, output_folder, job_identifier):\n        \"\"\"\n        Reconstructs the original files from a binary sequence.\n\n        :param raw_data: A RawData object.\n        :param output_folder: The folder where the restored files will be saved.\n        \"\"\"\n        # Suppress the specific DeprecationWarning\n        # Warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n\n        self.file_paths = raw_data.file_paths\n        self.data = raw_data.data\n\n        # Convert binary sequence back to bytes\n        byte_data = bytes(int(self.data[i:i+8], 2) for i in range(0, len(self.data), 8))\n\n        # Create a temporary tar archive file\n        archive_name = os.path.join(output_folder, job_identifier + '_restored.tar.gz')\n        with open(archive_name, 'wb') as file:\n            file.write(byte_data)\n\n        # Extract the tar archive\n        with tarfile.open(archive_name, 'r:gz') as archive:\n            for member in archive.getmembers():\n                # Remove the path information and add \"_restored\" to the file name\n                original_name = os.path.basename(member.name)\n                restored_name = f\"{os.path.splitext(original_name)[0]}_restored{os.path.splitext(original_name)[1]}\"\n                member.name = restored_name\n                archive.extract(member, output_folder)\n\n        # Remove the temporary tar archive file\n        #os.remove(archive_name)\n\n\n    def __str__(self):\n        output = \"DATA: \" + str(self.data)[:50] + \"...\\n\"\n\n        # output = \"\\n\" + \"Type: \" + str(type(self)) + \"\\n\"\n        # if self.file_paths is not None:\n        #     output += \"File paths: \" + str(self.file_paths) + \"\\n\"\n        #     output += \"Bytes:\" + str(self.calculate_total_bytes()) + \"\\n\"\n        # output += \"DATA: \" + str(self.data)[:200] + \"...\\n\"\n        return output\n</code></pre>"},{"location":"reference/#dnabyte.data.RestoredData.__init__","title":"<code>__init__(raw_data, output_folder, job_identifier)</code>","text":"<p>Reconstructs the original files from a binary sequence.</p> <p>:param raw_data: A RawData object. :param output_folder: The folder where the restored files will be saved.</p> Source code in <code>dnabyte/data.py</code> <pre><code>def __init__(self, raw_data, output_folder, job_identifier):\n    \"\"\"\n    Reconstructs the original files from a binary sequence.\n\n    :param raw_data: A RawData object.\n    :param output_folder: The folder where the restored files will be saved.\n    \"\"\"\n    # Suppress the specific DeprecationWarning\n    # Warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n\n    self.file_paths = raw_data.file_paths\n    self.data = raw_data.data\n\n    # Convert binary sequence back to bytes\n    byte_data = bytes(int(self.data[i:i+8], 2) for i in range(0, len(self.data), 8))\n\n    # Create a temporary tar archive file\n    archive_name = os.path.join(output_folder, job_identifier + '_restored.tar.gz')\n    with open(archive_name, 'wb') as file:\n        file.write(byte_data)\n\n    # Extract the tar archive\n    with tarfile.open(archive_name, 'r:gz') as archive:\n        for member in archive.getmembers():\n            # Remove the path information and add \"_restored\" to the file name\n            original_name = os.path.basename(member.name)\n            restored_name = f\"{os.path.splitext(original_name)[0]}_restored{os.path.splitext(original_name)[1]}\"\n            member.name = restored_name\n            archive.extract(member, output_folder)\n</code></pre>"},{"location":"reference/#params","title":"Params","text":""},{"location":"reference/#dnabyte.params.Params","title":"<code>Params</code>","text":"Source code in <code>dnabyte/params.py</code> <pre><code>class Params:\n    def __init__(self, \n                 name=None, \n                 filename=None, \n                 assembly_structure=None, \n                 encoding_scheme=None, \n                 inner_error_correction=None, \n                 outer_error_correction=None,\n                 dna_barcode_length=None, \n                 codeword_maxlength_positions=None, \n                 sigma_amount=None, \n                 codeword_length=None, \n                 percent_of_symbols=None,\n                 index_carry_length=None, \n                 reed_solo_percentage=None, \n                 synthesis_method=None, \n                 mean=None, \n                 vol=None, \n                 std_dev=None, \n                 hybridisation_steps=None, \n                 years=None, \n                 storage_conditions=None, \n                 sequencing_method=None, \n                 iid_error_rate=None,\n                 library_name=None,\n                 seed=None, \n                 debug=False,\n                 theory=None,\n                 ltcode_header=None):\n        self.name = name\n        self.filename = filename\n        self.assembly_structure = assembly_structure\n        self.encoding_scheme = encoding_scheme\n        self.inner_error_correction = inner_error_correction\n        self.outer_error_correction = outer_error_correction\n        self.dna_barcode_length = dna_barcode_length\n        self.codeword_maxlength_positions = codeword_maxlength_positions\n        self.sigma_amount = sigma_amount\n        self.codeword_length = codeword_length\n        self.percent_of_symbols = percent_of_symbols\n        self.index_carry_length = index_carry_length\n        self.reed_solo_percentage = reed_solo_percentage\n        self.synthesis_method = synthesis_method\n        self.mean = mean\n        self.vol = vol\n        self.std_dev = std_dev\n        self.hybridisation_steps = hybridisation_steps\n        self.years = years\n        self.storage_conditions = storage_conditions\n        self.sequencing_method = sequencing_method\n        self.library_name = library_name\n        self.seed = seed\n        self.debug = debug\n        self.theory = theory\n        self.ltcode_header = ltcode_header\n\n        # check the validity of the parameters\n        if self.sequencing_method == 'iid':\n            self.iid_error_rate = iid_error_rate\n\n        # check that the library is compatible with the selected assembly structure\n        if self.library_name is not None:\n            with open('./app/static/libraries/' + self.library_name, 'r') as f:\n                first_line = f.readline().strip() \n            if assembly_structure == 'linear_assembly':\n                if first_line == 'Messages':\n                    raise ValueError(\"Library not compatible with linear assembly\")\n                else:\n                    self.library = Library(structure=assembly_structure, filename='./app/static/libraries/' + library_name)\n            elif assembly_structure == 'positional_assembly':\n                if first_line == 'Messages':\n                    self.library = Library(structure=assembly_structure, filename='./app/static/libraries/' + library_name)\n                else:\n                    raise ValueError(\"Library not compatible with positional assembly\")\n            else:\n                raise ValueError(\"Library not compatible with synthesis\")\n\n        #assure message carring part is at least 1 oligo long\n        if assembly_structure == 'linear_assembly':\n            if encoding_scheme == 'linear_encoding':\n                max_codeword_length = codeword_length\n            elif encoding_scheme == 'binomial_encoding':\n                max_codeword_length = len(self.library.leftmotives) + len(self.library.rightmotives) - 1\n        elif assembly_structure == 'positional_assembly':\n            max_codeword_length = len(self.library.position) - 1\n        if inner_error_correction == 'ltcode':\n            message_length = max_codeword_length - dna_barcode_length - codeword_maxlength_positions - 1 - index_carry_length - ltcode_header\n        else:\n            message_length = max_codeword_length - dna_barcode_length - codeword_maxlength_positions - 1\n        if message_length &lt; 1:\n            raise ValueError(\"Invalid code word split.\")\n\n        if self.encoding_scheme not in ['linear_encoding', 'binomial_encoding', 'max_density_encoding', 'no_homopolymer_encoding','no_homopolymeroddeven_encoding']:\n            raise ValueError(\"Invalid encoding scheme\")\n\n        if self.assembly_structure not in ['synthesis', 'linear_assembly', 'positional_assembly']:\n            raise ValueError(\"Invalid library structure\")\n\n\n        if self.inner_error_correction not in ['ltcode', None]:\n            raise ValueError(\"Invalid inner error correction\")\n\n        if self.outer_error_correction not in ['reedsolomon', None]:\n            raise ValueError(\"Invalid outer error correction\")\n\n        if self.outer_error_correction == 'reedsolomon':\n            if self.reed_solo_percentage &lt; 0 or self.reed_solo_percentage &gt; 100:\n                raise ValueError(\"Reedsolomon percentage not compatible\")\n\n        if self.inner_error_correction == 'ltcode':\n            if self.percent_of_symbols &lt; 0 or self.percent_of_symbols &gt; 100:\n                raise ValueError(\"Percent of symbols not compatible\")\n\n            if self.index_carry_length &lt; 0:\n                raise ValueError(\"Index carry length not compatible\")    \n\n        if self.assembly_structure == 'positional_assembly' or self.assembly_structure == 'linear_assembly':\n            if self.library is None or self.library_name is None:\n                raise ValueError(\"Library not provided\")\n\n        if self.encoding_scheme == 'binomial_encoding':\n            if self.sigma_amount is None or self.theory is None:\n                raise ValueError(\"Missing parameters for encoding scheme\")\n\n        if self.encoding_scheme == 'linear_encoding' and self.assembly_structure == 'linear_assembly':\n            if self.codeword_length is None or self.theory is None:\n                raise ValueError(\"Missing parameters for encoding scheme\")\n\n        if (self.assembly_structure == 'synthesis' or (self.assembly_structure == 'linear_assembly' and self.encoding_scheme == 'linear_encoding')):\n            if self.codeword_length is None:\n                raise ValueError(\"Missing parameters for encoding scheme\")\n\n        if self.encoding_scheme == 'linear_encoding' and self.assembly_structure == 'positional_assembly':\n            if self.theory is None:\n                raise ValueError(\"Missing parameters for encoding scheme\")\n\n        if self.sequencing_method not in [41, 40, 37, 36, 39, 38, 35,'iid', None]:\n            raise ValueError(\"Invalid sequencing method\")\n\n        if self.synthesis_method not in [3, 4, 5, 6, 7, 68, 69, 70, 71, 'nosynthpoly', None]:\n            raise ValueError(\"Invalid Synthesis Error\")\n\n        if self.storage_conditions not in ['permafrost', 'room_temperature', 'biogene', None]:\n            raise ValueError(\"Invalid storage conditions\")\n\n        # NOTE: This is here for testing library distances, to be removed after simulations are done\n\n        # min_distance = float('inf')  # Initialize with infinity\n        # closest_strings = []         # List to store strings with the smallest distance\n\n        # for m in self.library.library:\n        #     for s in self.library.library:\n        #         if m != s:  # Avoid comparing the same string\n        #             distance = damerau_levenshtein_distance(m, s)  # Calculate the distance\n        #             if distance &lt; min_distance:\n        #                 min_distance = distance  # Update the smallest distance\n\n        # print(f\"Minimum distance: {min_distance}\")\n        # breakpoint()\n\n\n    def __str__(self):\n        output = f\"Name: {self.name}\\n\"\n        output += f\"Filename: {self.filename}\\n\"\n        output += f\"Assembly structure: {self.assembly_structure}\\n\"\n        output += f\"Encoding scheme: {self.encoding_scheme}\\n\"\n        output += f\"Inner error correction: {self.inner_error_correction}\\n\"\n        output += f\"Outer error correction: {self.outer_error_correction}\\n\"\n        output += f\"DNA barcode length: {self.dna_barcode_length}\\n\"\n        output += f\"Codeword max length positions: {self.codeword_maxlength_positions}\\n\"\n        output += f\"Sigma amount: {self.sigma_amount}\\n\"\n        output += f\"Codeword length: {self.codeword_length}\\n\"\n        output += f\"Percent of symbols: {self.percent_of_symbols}\\n\"\n        output += f\"Index carry length: {self.index_carry_length}\\n\"\n        output += f\"Reed-Solo percentage: {self.reed_solo_percentage}\\n\"\n        output += f\"Synthesis method: {self.synthesis_method}\\n\"\n        output += f\"Mean: {self.mean}\\n\"\n        output += f\"Volume: {self.vol}\\n\"\n        output += f\"Standard deviation: {self.std_dev}\\n\"\n        output += f\"Hybridisation steps: {self.hybridisation_steps}\\n\"\n        output += f\"Years: {self.years}\\n\"\n        output += f\"Storage conditions: {self.storage_conditions}\\n\"\n        output += f\"Sequencing method: {self.sequencing_method}\\n\"\n        output += f\"Library name: {self.library_name}\\n\"\n        output += f\"Seed: {self.seed}\\n\"\n        output += f\"Debug: {self.debug}\\n\"\n        output += f\"Theory: {self.theory}\\n\"\n        return output\n\n\n    @classmethod\n    def params_range(cls, **kwargs):\n        \"\"\"\n        Alternative constructor that creates a list of Params instances for each item in the list if one of the parameters is a non-empty list.\n\n        Parameters:\n        kwargs (dict): The parameters for the Params instances.\n\n        Returns:\n        list: A list of Params instances.\n        \"\"\"\n        params_list = []\n\n        # Find the first attribute that is a non-empty list\n        for attr_name, attr_value in kwargs.items():\n            if isinstance(attr_value, list) and attr_value:\n                for item in attr_value:\n                    new_kwargs = {**kwargs, attr_name: item}\n                    params_list.append(cls(**new_kwargs))\n                break\n        else:\n            # If no attribute is a non-empty list, return a list with a single instance\n            params_list.append(cls(**kwargs))\n\n        return params_list\n</code></pre>"},{"location":"reference/#dnabyte.params.Params.params_range","title":"<code>params_range(**kwargs)</code>  <code>classmethod</code>","text":"<p>Alternative constructor that creates a list of Params instances for each item in the list if one of the parameters is a non-empty list.</p> <p>Parameters: kwargs (dict): The parameters for the Params instances.</p> <p>Returns: list: A list of Params instances.</p> Source code in <code>dnabyte/params.py</code> <pre><code>@classmethod\ndef params_range(cls, **kwargs):\n    \"\"\"\n    Alternative constructor that creates a list of Params instances for each item in the list if one of the parameters is a non-empty list.\n\n    Parameters:\n    kwargs (dict): The parameters for the Params instances.\n\n    Returns:\n    list: A list of Params instances.\n    \"\"\"\n    params_list = []\n\n    # Find the first attribute that is a non-empty list\n    for attr_name, attr_value in kwargs.items():\n        if isinstance(attr_value, list) and attr_value:\n            for item in attr_value:\n                new_kwargs = {**kwargs, attr_name: item}\n                params_list.append(cls(**new_kwargs))\n            break\n    else:\n        # If no attribute is a non-empty list, return a list with a single instance\n        params_list.append(cls(**kwargs))\n\n    return params_list\n</code></pre>"},{"location":"reference/#encode","title":"Encode","text":""},{"location":"reference/#dnabyte.encode.Encode","title":"<code>Encode</code>","text":"<p>This class is responsible for encoding the raw data into sequences of oligos.</p> <p>There are three steps involved in encoding: 1. Splitting raw data into codewords. This step also includes error correction and barcoding. 2. Encoding the codewords into sequences of oligos. This is called the blueprint. 3. Subsetting the blueprint into pooling sequences.</p> Source code in <code>dnabyte/encode.py</code> <pre><code>class Encode:\n    \"\"\"\n    This class is responsible for encoding the raw data into sequences of oligos.\n\n    There are three steps involved in encoding:\n    1. Splitting raw data into codewords. This step also includes error correction and barcoding.\n    2. Encoding the codewords into sequences of oligos. This is called the blueprint.\n    3. Subsetting the blueprint into pooling sequences. \n\n    \"\"\"\n\n    def __init__(self, params, logger=None):\n\n        self.assembly_structure = params.assembly_structure\n        self.encoding_scheme = params.encoding_scheme\n        self.inner_error_correction = params.inner_error_correction\n        self.outer_error_correction = params.outer_error_correction\n        self.dna_barcode_length = params.dna_barcode_length\n        self.codeword_maxlength_positions = params.codeword_maxlength_positions\n        self.sigmaamount = params.sigma_amount\n        self.codewordlength = params.codeword_length\n        self.percentofsymbols = params.percent_of_symbols\n        self.indexcarrylength = params.index_carry_length\n        self.reedsolopercentage = params.reed_solo_percentage\n        self.library_name = params.library_name\n        self.library = params.library\n        self.theory = params.theory\n        self.logger = logger\n        self.params = params\n\n\n    def encode(self, raw_data):\n        \"\"\"\n        Encodes the raw data based on the library structure and encoding scheme.\n\n        This method encodes the provided raw data using the specified encoding scheme\n        and library structure. The encoding scheme and library structure determine\n        which encoding function is used.\n\n        Parameters:\n        raw_data (RawData): The raw data to be encoded. Must be an instance of RawData.\n\n        Returns:\n        EncodedData: An EncodedData object containing the encoded data.\n\n        Raises:\n        TypeError: If raw_data is not an instance of RawData.\n        ValueError: If the encoding scheme or library structure is invalid.\n\n        Encoding Schemes:\n        - 'linear_assembly' structure with 'linear_encoding' encoding: Uses Encode_chain_simp.\n        - 'linear_assembly' structure with 'binomial_encoding' encoding: Uses Encode_binom_simp.\n        - 'positional_assembly' structure with 'linear_encoding' encoding: Uses Encode_chain_poly.\n        - 'positional_assembly' structure with 'binomial_encoding' encoding: Uses Encode_binom_poly.\n        \"\"\"\n\n        from dnabyte.encode_maxdensity import EncodeMaxDensity\n        from dnabyte.encode_nohomopolyoddeven import EncodeNoHomoPolyOddEven\n        from dnabyte.encode_linear_chain import EncodeLinearChain\n        from dnabyte.encode_linear_binom import EncodeLinearBinom\n        from dnabyte.encode_poly_chain import EncodePolyChain\n        from dnabyte.encode_poly_binom import EncodePolyBinom\n\n\n        if not isinstance(raw_data, RawData):\n            raise TypeError(\"raw_data must be an instance of RawData\")\n\n        if self.assembly_structure == 'linear_assembly' and self.encoding_scheme == 'linear_encoding':\n            enc = EncodeLinearChain(self.params, logger=self.logger)\n            encoded_data, info = enc.encode_linear_chain(raw_data)\n\n        elif self.assembly_structure == 'linear_assembly' and self.encoding_scheme == 'binomial_encoding':\n            enc = EncodeLinearBinom(self.params, logger=self.logger)\n            encoded_data, info = enc.encode_linear_binom(raw_data)\n\n        elif self.assembly_structure == 'positional_assembly' and self.encoding_scheme == 'linear_encoding':\n            enc = EncodePolyChain(self.params, logger=self.logger)\n            encoded_data, info = enc.encode_chain_poly(raw_data)\n\n        elif self.assembly_structure == 'positional_assembly' and self.encoding_scheme == 'binomial_encoding':\n            enc = EncodePolyBinom(self.params, logger=self.logger)\n            encoded_data, info = enc.encode_binom_poly(raw_data)\n\n        elif self.assembly_structure == 'synthesis' and self.encoding_scheme == 'max_density_encoding':\n            enc = EncodeMaxDensity(self.params, logger=self.logger)\n            encoded_data, info = enc.encode_max_density(raw_data)\n\n        elif self.assembly_structure == 'synthesis' and self.encoding_scheme == 'no_homopolymeroddeven_encoding':\n            enc = EncodeNoHomoPolyOddEven(self.params, logger=self.logger)\n            encoded_data, info = enc.encode_nohomopoly_odd_even(raw_data)\n\n        else:\n            raise ValueError(\"Invalid encoding scheme or library structure\")\n\n        obj = EncodedData(encoded_data)\n        obj.file_paths = raw_data.file_paths\n\n        return obj, info\n\n\n    def decode(self, corrected_data):\n\n        \"\"\"\n        Decodes the corrected data based on the assembly structure and encoding scheme.\n\n        This method decodes the provided corrected data using the specified assembly structure\n        and encoding scheme. The assembly structure and encoding scheme determine\n        which decoding function is used.\n\n        Parameters:\n        corrected_data (CorrectedData): The corrected data to be decoded. Must be an instance of CorrectedData.\n\n        Returns:\n        DecodedData: A DecodedData object containing the decoded data.\n\n        Raises:\n        TypeError: If corrected_data is not an instance of CorrectedData.\n        ValueError: If the encoding scheme or library structure is invalid.\n\n        Assembly Structures:\n        - 'linear_assembly' with 'linear_encoding' encoding: Uses Decode_simple_chain.\n        - 'linear_assembly' with 'binomial_encoding' encoding: Uses Decode_simple_binom.\n        - 'positional_assembly' with 'linear_encoding' encoding: Uses Decode_poly_chain.\n        - 'positional_assembly' with 'binomial_encoding' encoding: Uses Decode_poly_binom.\n        \"\"\"\n\n        from dnabyte.decode_linear_chain import DecodeLinearChain\n        from dnabyte.decode_linear_binom import DecodeLinearBinom\n        from dnabyte.decode_poly_chain import DecodePolyChain\n        from dnabyte.decode_poly_binom import DecodePolyBinom\n        from dnabyte.decode_maxdensity import DecodeMaxDensity\n        from dnabyte.decode_nohomopolyoddeven import DecodeNoHomoPolyOddEven\n\n        if not isinstance(corrected_data, CorrectedData):\n            raise TypeError(\"corrected_data must be an instance of CorrectedData\")\n\n        if self.params.assembly_structure == 'linear_assembly' and self.params.encoding_scheme == 'linear_encoding':\n            dec = DecodeLinearChain(self.params, logger=self.logger)\n            decoded_data, valid, info = dec.decode_linear_chain(corrected_data)\n\n        elif self.params.assembly_structure == 'linear_assembly' and self.params.encoding_scheme == 'binomial_encoding':\n            dec = DecodeLinearBinom(self.params, logger=self.logger)\n            decoded_data, valid, info = dec.decode_linear_binom(corrected_data)\n\n        elif self.params.assembly_structure == 'positional_assembly' and self.params.encoding_scheme == 'linear_encoding':\n            dec = DecodePolyChain(self.params, logger=self.logger)\n            decoded_data, valid, info = dec.decode_poly_chain(corrected_data)\n\n        elif self.params.assembly_structure == 'positional_assembly' and self.params.encoding_scheme == 'binomial_encoding':\n            dec = DecodePolyBinom(self.params, logger=self.logger)\n            decoded_data, valid, info = dec.decode_poly_binom(corrected_data)\n\n        elif self.params.assembly_structure == 'synthesis' and self.params.encoding_scheme == 'max_density_encoding':\n            dec = DecodeMaxDensity(self.params, logger=self.logger)\n            decoded_data, valid, info = dec.decode_maxdensity(corrected_data)\n\n        elif self.params.assembly_structure == 'synthesis' and self.params.encoding_scheme == 'no_homopolymeroddeven_encoding':\n            dec = DecodeNoHomoPolyOddEven(self.params, logger=self.logger)\n            decoded_data, valid, info = dec.decode_nohomopolyoddeven(corrected_data)\n\n        else:\n            raise ValueError(\"Invalid encoding scheme or library structure\")\n\n        obj = DecodedData(corrected_data)\n        obj.data = decoded_data\n\n        return obj, valid, info\n\n\n    def process(self, data):\n\n        \"\"\"\n        Processes the sequenced data based on the assembly structure and encoding scheme.\n\n        This method processes the provided sequenced data using the specified assembly structure\n        and encoding scheme. The assembly structure and encoding scheme determine\n        which processing function is used.\n\n        Parameters:\n        data (SequencedData): The sequenced data to be processed. Must be an instance of SequencedData.\n\n        Returns:\n        CorrectedData: A CorrectedData object containing the processed data.\n\n        Raises:\n        TypeError: If data is not an instance of SequencedData.\n        ValueError: If the encoding scheme or library structure is invalid.\n\n        Assembly Structures:\n        - 'linear_assembly' with 'linear_encoding' encoding: Uses Process.\n        - 'linear_assembly' with 'binomial_encoding' encoding: Uses Process.\n        - 'positional_assembly' with 'linear_encoding' encoding: Uses Process.\n        - 'positional_assembly' with 'binomial_encoding' encoding: Uses Process.\n        \"\"\"\n\n        from dnabyte.process_maxdensity import ProcessMaxDensity\n        from dnabyte.process_nohomopolyoddeven import ProcessNoHomoPolyOddEven\n        from dnabyte.process_linear_chain import ProcessLinearChain\n        from dnabyte.process_linear_binom import ProcessLinearBinom\n        from dnabyte.process_poly_chain import ProcessPolyChain\n        from dnabyte.process_poly_binom import ProcessPolyBinom\n\n        if data is not None and isinstance(data, SequencedData):\n\n            if self.assembly_structure == 'synthesis' and self.encoding_scheme == 'max_density_encoding':\n                pro = ProcessMaxDensity(self.params, logger=self.logger)\n                processed_data, info = pro.process_maxdensity(data)\n\n            if self.assembly_structure == 'synthesis' and self.encoding_scheme == 'no_homopolymeroddeven_encoding':\n                pro = ProcessNoHomoPolyOddEven(self.params, logger=self.logger)\n                processed_data, info = pro.process_nohomopolyoddeven(data)\n\n            if self.assembly_structure == 'linear_assembly' and self.encoding_scheme == 'linear_encoding':\n                pro = ProcessLinearChain(self.params, logger=self.logger)\n                processed_data, info = pro.process_linear_chain(data)\n\n            elif self.assembly_structure == 'linear_assembly' and self.encoding_scheme == 'binomial_encoding':\n                pro = ProcessLinearBinom(self.params, logger=self.logger)\n                processed_data, info = pro.process_linear_binom(data)\n\n            elif self.assembly_structure == 'positional_assembly' and self.encoding_scheme == 'linear_encoding':\n                pro = ProcessPolyChain(self.params, logger=self.logger)\n                processed_data, info = pro.process_poly_chain(data)\n\n            elif self.assembly_structure == 'positional_assembly' and self.encoding_scheme == 'binomial_encoding':\n                pro = ProcessPolyBinom(self.params, logger=self.logger)\n                processed_data, info = pro.process_poly_binom(data)\n\n        obj = CorrectedData(data)\n        obj.data = processed_data\n\n        return obj, info\n</code></pre>"},{"location":"reference/#dnabyte.encode.Encode.decode","title":"<code>decode(corrected_data)</code>","text":"<p>Decodes the corrected data based on the assembly structure and encoding scheme.</p> <p>This method decodes the provided corrected data using the specified assembly structure and encoding scheme. The assembly structure and encoding scheme determine which decoding function is used.</p> <p>Parameters: corrected_data (CorrectedData): The corrected data to be decoded. Must be an instance of CorrectedData.</p> <p>Returns: DecodedData: A DecodedData object containing the decoded data.</p> <p>Raises: TypeError: If corrected_data is not an instance of CorrectedData. ValueError: If the encoding scheme or library structure is invalid.</p> <p>Assembly Structures: - 'linear_assembly' with 'linear_encoding' encoding: Uses Decode_simple_chain. - 'linear_assembly' with 'binomial_encoding' encoding: Uses Decode_simple_binom. - 'positional_assembly' with 'linear_encoding' encoding: Uses Decode_poly_chain. - 'positional_assembly' with 'binomial_encoding' encoding: Uses Decode_poly_binom.</p> Source code in <code>dnabyte/encode.py</code> <pre><code>def decode(self, corrected_data):\n\n    \"\"\"\n    Decodes the corrected data based on the assembly structure and encoding scheme.\n\n    This method decodes the provided corrected data using the specified assembly structure\n    and encoding scheme. The assembly structure and encoding scheme determine\n    which decoding function is used.\n\n    Parameters:\n    corrected_data (CorrectedData): The corrected data to be decoded. Must be an instance of CorrectedData.\n\n    Returns:\n    DecodedData: A DecodedData object containing the decoded data.\n\n    Raises:\n    TypeError: If corrected_data is not an instance of CorrectedData.\n    ValueError: If the encoding scheme or library structure is invalid.\n\n    Assembly Structures:\n    - 'linear_assembly' with 'linear_encoding' encoding: Uses Decode_simple_chain.\n    - 'linear_assembly' with 'binomial_encoding' encoding: Uses Decode_simple_binom.\n    - 'positional_assembly' with 'linear_encoding' encoding: Uses Decode_poly_chain.\n    - 'positional_assembly' with 'binomial_encoding' encoding: Uses Decode_poly_binom.\n    \"\"\"\n\n    from dnabyte.decode_linear_chain import DecodeLinearChain\n    from dnabyte.decode_linear_binom import DecodeLinearBinom\n    from dnabyte.decode_poly_chain import DecodePolyChain\n    from dnabyte.decode_poly_binom import DecodePolyBinom\n    from dnabyte.decode_maxdensity import DecodeMaxDensity\n    from dnabyte.decode_nohomopolyoddeven import DecodeNoHomoPolyOddEven\n\n    if not isinstance(corrected_data, CorrectedData):\n        raise TypeError(\"corrected_data must be an instance of CorrectedData\")\n\n    if self.params.assembly_structure == 'linear_assembly' and self.params.encoding_scheme == 'linear_encoding':\n        dec = DecodeLinearChain(self.params, logger=self.logger)\n        decoded_data, valid, info = dec.decode_linear_chain(corrected_data)\n\n    elif self.params.assembly_structure == 'linear_assembly' and self.params.encoding_scheme == 'binomial_encoding':\n        dec = DecodeLinearBinom(self.params, logger=self.logger)\n        decoded_data, valid, info = dec.decode_linear_binom(corrected_data)\n\n    elif self.params.assembly_structure == 'positional_assembly' and self.params.encoding_scheme == 'linear_encoding':\n        dec = DecodePolyChain(self.params, logger=self.logger)\n        decoded_data, valid, info = dec.decode_poly_chain(corrected_data)\n\n    elif self.params.assembly_structure == 'positional_assembly' and self.params.encoding_scheme == 'binomial_encoding':\n        dec = DecodePolyBinom(self.params, logger=self.logger)\n        decoded_data, valid, info = dec.decode_poly_binom(corrected_data)\n\n    elif self.params.assembly_structure == 'synthesis' and self.params.encoding_scheme == 'max_density_encoding':\n        dec = DecodeMaxDensity(self.params, logger=self.logger)\n        decoded_data, valid, info = dec.decode_maxdensity(corrected_data)\n\n    elif self.params.assembly_structure == 'synthesis' and self.params.encoding_scheme == 'no_homopolymeroddeven_encoding':\n        dec = DecodeNoHomoPolyOddEven(self.params, logger=self.logger)\n        decoded_data, valid, info = dec.decode_nohomopolyoddeven(corrected_data)\n\n    else:\n        raise ValueError(\"Invalid encoding scheme or library structure\")\n\n    obj = DecodedData(corrected_data)\n    obj.data = decoded_data\n\n    return obj, valid, info\n</code></pre>"},{"location":"reference/#dnabyte.encode.Encode.encode","title":"<code>encode(raw_data)</code>","text":"<p>Encodes the raw data based on the library structure and encoding scheme.</p> <p>This method encodes the provided raw data using the specified encoding scheme and library structure. The encoding scheme and library structure determine which encoding function is used.</p> <p>Parameters: raw_data (RawData): The raw data to be encoded. Must be an instance of RawData.</p> <p>Returns: EncodedData: An EncodedData object containing the encoded data.</p> <p>Raises: TypeError: If raw_data is not an instance of RawData. ValueError: If the encoding scheme or library structure is invalid.</p> <p>Encoding Schemes: - 'linear_assembly' structure with 'linear_encoding' encoding: Uses Encode_chain_simp. - 'linear_assembly' structure with 'binomial_encoding' encoding: Uses Encode_binom_simp. - 'positional_assembly' structure with 'linear_encoding' encoding: Uses Encode_chain_poly. - 'positional_assembly' structure with 'binomial_encoding' encoding: Uses Encode_binom_poly.</p> Source code in <code>dnabyte/encode.py</code> <pre><code>def encode(self, raw_data):\n    \"\"\"\n    Encodes the raw data based on the library structure and encoding scheme.\n\n    This method encodes the provided raw data using the specified encoding scheme\n    and library structure. The encoding scheme and library structure determine\n    which encoding function is used.\n\n    Parameters:\n    raw_data (RawData): The raw data to be encoded. Must be an instance of RawData.\n\n    Returns:\n    EncodedData: An EncodedData object containing the encoded data.\n\n    Raises:\n    TypeError: If raw_data is not an instance of RawData.\n    ValueError: If the encoding scheme or library structure is invalid.\n\n    Encoding Schemes:\n    - 'linear_assembly' structure with 'linear_encoding' encoding: Uses Encode_chain_simp.\n    - 'linear_assembly' structure with 'binomial_encoding' encoding: Uses Encode_binom_simp.\n    - 'positional_assembly' structure with 'linear_encoding' encoding: Uses Encode_chain_poly.\n    - 'positional_assembly' structure with 'binomial_encoding' encoding: Uses Encode_binom_poly.\n    \"\"\"\n\n    from dnabyte.encode_maxdensity import EncodeMaxDensity\n    from dnabyte.encode_nohomopolyoddeven import EncodeNoHomoPolyOddEven\n    from dnabyte.encode_linear_chain import EncodeLinearChain\n    from dnabyte.encode_linear_binom import EncodeLinearBinom\n    from dnabyte.encode_poly_chain import EncodePolyChain\n    from dnabyte.encode_poly_binom import EncodePolyBinom\n\n\n    if not isinstance(raw_data, RawData):\n        raise TypeError(\"raw_data must be an instance of RawData\")\n\n    if self.assembly_structure == 'linear_assembly' and self.encoding_scheme == 'linear_encoding':\n        enc = EncodeLinearChain(self.params, logger=self.logger)\n        encoded_data, info = enc.encode_linear_chain(raw_data)\n\n    elif self.assembly_structure == 'linear_assembly' and self.encoding_scheme == 'binomial_encoding':\n        enc = EncodeLinearBinom(self.params, logger=self.logger)\n        encoded_data, info = enc.encode_linear_binom(raw_data)\n\n    elif self.assembly_structure == 'positional_assembly' and self.encoding_scheme == 'linear_encoding':\n        enc = EncodePolyChain(self.params, logger=self.logger)\n        encoded_data, info = enc.encode_chain_poly(raw_data)\n\n    elif self.assembly_structure == 'positional_assembly' and self.encoding_scheme == 'binomial_encoding':\n        enc = EncodePolyBinom(self.params, logger=self.logger)\n        encoded_data, info = enc.encode_binom_poly(raw_data)\n\n    elif self.assembly_structure == 'synthesis' and self.encoding_scheme == 'max_density_encoding':\n        enc = EncodeMaxDensity(self.params, logger=self.logger)\n        encoded_data, info = enc.encode_max_density(raw_data)\n\n    elif self.assembly_structure == 'synthesis' and self.encoding_scheme == 'no_homopolymeroddeven_encoding':\n        enc = EncodeNoHomoPolyOddEven(self.params, logger=self.logger)\n        encoded_data, info = enc.encode_nohomopoly_odd_even(raw_data)\n\n    else:\n        raise ValueError(\"Invalid encoding scheme or library structure\")\n\n    obj = EncodedData(encoded_data)\n    obj.file_paths = raw_data.file_paths\n\n    return obj, info\n</code></pre>"},{"location":"reference/#dnabyte.encode.Encode.process","title":"<code>process(data)</code>","text":"<p>Processes the sequenced data based on the assembly structure and encoding scheme.</p> <p>This method processes the provided sequenced data using the specified assembly structure and encoding scheme. The assembly structure and encoding scheme determine which processing function is used.</p> <p>Parameters: data (SequencedData): The sequenced data to be processed. Must be an instance of SequencedData.</p> <p>Returns: CorrectedData: A CorrectedData object containing the processed data.</p> <p>Raises: TypeError: If data is not an instance of SequencedData. ValueError: If the encoding scheme or library structure is invalid.</p> <p>Assembly Structures: - 'linear_assembly' with 'linear_encoding' encoding: Uses Process. - 'linear_assembly' with 'binomial_encoding' encoding: Uses Process. - 'positional_assembly' with 'linear_encoding' encoding: Uses Process. - 'positional_assembly' with 'binomial_encoding' encoding: Uses Process.</p> Source code in <code>dnabyte/encode.py</code> <pre><code>def process(self, data):\n\n    \"\"\"\n    Processes the sequenced data based on the assembly structure and encoding scheme.\n\n    This method processes the provided sequenced data using the specified assembly structure\n    and encoding scheme. The assembly structure and encoding scheme determine\n    which processing function is used.\n\n    Parameters:\n    data (SequencedData): The sequenced data to be processed. Must be an instance of SequencedData.\n\n    Returns:\n    CorrectedData: A CorrectedData object containing the processed data.\n\n    Raises:\n    TypeError: If data is not an instance of SequencedData.\n    ValueError: If the encoding scheme or library structure is invalid.\n\n    Assembly Structures:\n    - 'linear_assembly' with 'linear_encoding' encoding: Uses Process.\n    - 'linear_assembly' with 'binomial_encoding' encoding: Uses Process.\n    - 'positional_assembly' with 'linear_encoding' encoding: Uses Process.\n    - 'positional_assembly' with 'binomial_encoding' encoding: Uses Process.\n    \"\"\"\n\n    from dnabyte.process_maxdensity import ProcessMaxDensity\n    from dnabyte.process_nohomopolyoddeven import ProcessNoHomoPolyOddEven\n    from dnabyte.process_linear_chain import ProcessLinearChain\n    from dnabyte.process_linear_binom import ProcessLinearBinom\n    from dnabyte.process_poly_chain import ProcessPolyChain\n    from dnabyte.process_poly_binom import ProcessPolyBinom\n\n    if data is not None and isinstance(data, SequencedData):\n\n        if self.assembly_structure == 'synthesis' and self.encoding_scheme == 'max_density_encoding':\n            pro = ProcessMaxDensity(self.params, logger=self.logger)\n            processed_data, info = pro.process_maxdensity(data)\n\n        if self.assembly_structure == 'synthesis' and self.encoding_scheme == 'no_homopolymeroddeven_encoding':\n            pro = ProcessNoHomoPolyOddEven(self.params, logger=self.logger)\n            processed_data, info = pro.process_nohomopolyoddeven(data)\n\n        if self.assembly_structure == 'linear_assembly' and self.encoding_scheme == 'linear_encoding':\n            pro = ProcessLinearChain(self.params, logger=self.logger)\n            processed_data, info = pro.process_linear_chain(data)\n\n        elif self.assembly_structure == 'linear_assembly' and self.encoding_scheme == 'binomial_encoding':\n            pro = ProcessLinearBinom(self.params, logger=self.logger)\n            processed_data, info = pro.process_linear_binom(data)\n\n        elif self.assembly_structure == 'positional_assembly' and self.encoding_scheme == 'linear_encoding':\n            pro = ProcessPolyChain(self.params, logger=self.logger)\n            processed_data, info = pro.process_poly_chain(data)\n\n        elif self.assembly_structure == 'positional_assembly' and self.encoding_scheme == 'binomial_encoding':\n            pro = ProcessPolyBinom(self.params, logger=self.logger)\n            processed_data, info = pro.process_poly_binom(data)\n\n    obj = CorrectedData(data)\n    obj.data = processed_data\n\n    return obj, info\n</code></pre>"},{"location":"reference/#dnabyte.assembly.SimulateAssembly","title":"<code>SimulateAssembly</code>","text":"<p>Simulate the assembly of single stranded oligos into long chaines of double stranded DNA.</p> Source code in <code>dnabyte/assembly.py</code> <pre><code>class SimulateAssembly:\n    \"\"\"\n    Simulate the assembly of single stranded oligos into long chaines of double stranded DNA.\n    \"\"\"\n    def __init__(self, params, logger=None):\n\n            self.assembly_structure = params.assembly_structure\n            self.encoding_scheme = params.encoding_scheme\n            self.mean = params.mean\n            self.std_dev = params.std_dev\n            self.vol = params.vol\n            self.hybridisation_steps = params.hybridisation_steps\n            self.synthesis_method = params.synthesis_method\n            self.theory = params.theory\n            self.library = params.library\n\n            # To allow simulation with large quantites of oligos, we will scale down the number, perform\n            # the simulation, and then scale back up the results.\n            scale = 1\n            while self.mean &gt; 1000:\n                self.mean = self.mean / 10\n                self.std_dev = self.std_dev / 10\n                scale = scale * 10\n\n            self.scale = scale\n\n    def print_list_structure(self, lst, level=0):\n        \"\"\"\n        Recursively prints the structure of a list of lists.\n\n        Args:\n            lst (list): The list to analyze.\n            level (int): The current nesting level (used for indentation).\n        \"\"\"\n        if isinstance(lst, list):\n            print(\"  \" * level + f\"Level {level}: List with {len(lst)} elements\")\n            for item in lst:\n                self.print_list_structure(item, level + 1)\n        else:\n            if isinstance(lst, Oligo):\n                print(\"  \" * level + f\"Level {level}: {type(lst).__name__} ({lst})\")\n            elif isinstance(lst, OligoPool):\n                for oligo in lst.pool:\n                    print(\"  \" * level + f\"Level {level}: {type(oligo).__name__} ({oligo})\")\n\n\n\n    def process_tuple_list(tuple_list):\n        def flip_tuple(t):\n            return t[::-1]\n\n        # Ensure the tuple containing 'A' is the first tuple\n        if 'A' == tuple_list[1][0] or 'A' == tuple_list[1][-1]:\n            tuple_list = (tuple_list[1], tuple_list[0])\n\n        # Ensure 'A' is the first entry of the first tuple\n        if tuple_list[0][0] != 'A':\n            tuple_list = (flip_tuple(tuple_list[0]), flip_tuple(tuple_list[1]))\n\n        return tuple_list\n\n\n    # def add_empty_to_innermost(self, lst, library):\n    #     if isinstance(lst, list):\n    #         if all( isinstance(i, Oligo) for i in lst):\n    #             testvar = [[Oligo([complement(lst[0].motifs[0],library.dictmotives), 'empty']), lst[0]], lst[1]]\n    #             # print(testvar)\n    #             # breakpoint()\n    #             return [[Oligo([complement(lst[0].motifs[0],library.dictmotives), 'empty']), lst[0]], lst[1]]\n    #         else:\n    #             return [self.add_empty_to_innermost(i,library) for i in lst]\n    #     return lst\n    def add_empty_to_innermost(self, lst, library):\n        finishedlist = []\n        finishedlist.append(Oligo([complement(lst[0].motifs[0],library.dictmotives), 'empty']))\n        finishedlist.extend(lst)\n        return finishedlist\n\n    def print_nested_list(self,nested_list, level=0):\n        for item in nested_list:\n            if isinstance(item, list):\n                self.print_nested_list(item, level + 1)\n            else:\n                print(item,  'oligo')\n\n    def nest_list(self, lst):\n        \"\"\"\n        Recursively nests a list into the structure [[[[a, b], c], d], e].\n\n        Args:\n            lst (list): The input list to be nested.\n\n        Returns:\n            list: The nested list structure.\n        \"\"\"\n        if len(lst) &lt;= 1:\n            return lst  # Base case: if the list has 1 or fewer elements, return it as is\n        return [self.nest_list(lst[:-1]), lst[-1]]  # Recursively nest all but the last element with the last element\n\n\n    def simulate(self, encoded_data):\n\n        assembled_data = AssembledData(encoded_data)\n        assembled_data.scale = self.scale\n\n        if isinstance(encoded_data, EncodedData):\n\n            if self.assembly_structure == 'synthesis':\n\n                if self.synthesis_method == None:\n                    assembled_data.data = encoded_data.data\n                elif self.synthesis_method == 'nosynthpoly':\n                    sequences_multiples = [seq for seq in encoded_data.data for _ in range(max(1, int(np.random.normal(self.mean, self.std_dev))))]\n                    assembled_data.data = sequences_multiples\n                else:\n                    synthesized_data = synthesis_simulation(encoded_data.data, method_id=self.synthesis_method, mean=self.mean, std_dev=self.std_dev)\n                    assembled_data.data = synthesized_data\n\n            # linear assembly / linear encoding\n            elif self.assembly_structure == 'linear_assembly' and  self.encoding_scheme == 'linear_encoding':\n\n                restructuredlib = translate_nested_list(encoded_data.data, self.library.translationlibleft, self.library.translationlibright)\n\n                if self.theory == 'yes':\n                    poolingfinish = self.call_function_repeatedly_therory(restructuredlib, self.library, 'linear_encoding')\n                    retranslated = back_translate_nested_list_chain(poolingfinish, self.library.translationlibleft, self.library.translationlibright)\n                    assembled_data.data = retranslated\n\n                if self.theory == 'no':\n                    empyrestructuredlib = []\n                    for i in range(len(restructuredlib)):\n                        empyrestructuredlib.append(self.nest_list(self.add_empty_to_innermost(restructuredlib[i], self.library)))\n\n                    poolingfinish = self.call_function_repeatedly(empyrestructuredlib, self.library, 'linear_encoding')\n                    poolingfinish = flatten_at_layer(poolingfinish, 1)\n                    poolingfinish = OligoPool([]).join(pools=poolingfinish, mean=1, std_dev=0)\n                    retranslated = back_translate_nested_list_chain_real(poolingfinish, self.library.translationlibleft, self.library.translationlibright)\n                    assembled_data.data = retranslated\n\n            # linear assembly / binomial encoding\n            elif self.assembly_structure == 'linear_assembly' and  self.encoding_scheme == 'binomial_encoding':\n\n                restructuredlib = translate_nested_list(encoded_data.data, self.library.translationlibleft, self.library.translationlibright)\n\n                if self.theory == 'yes':\n                    poolingfinish = self.call_function_repeatedly_therory(restructuredlib, self.library, 'binomial_encoding')\n                    retranslated = back_translate_nested_list(poolingfinish, self.library.translationlibleft, self.library.translationlibright)\n                    retranslated = flatten_at_layer(retranslated, 1)\n                    assembled_data.data = retranslated\n\n                elif self.theory == 'no':\n                    poolingfinish = self.call_function_repeatedly(restructuredlib, self.library, 'binomial_encoding')\n                    retranslated = back_translate_nested_list_real(poolingfinish, self.library.translationlibleft, self.library.translationlibright)\n                    assembled_data.data = retranslated\n\n            # positional assembly / linear encoding\n            elif self.assembly_structure == 'positional_assembly' and self.encoding_scheme == 'linear_encoding':\n                restructuredlib = translate_nested_list_poly(encoded_data.data, self.library)\n\n                if self.theory == 'yes':\n                    poolingfinish = self.call_function_repeatedly(restructuredlib, self.library, 'linear_encoding')\n                    retranslated = back_translate_nested_list_poly(poolingfinish, self.library)\n                    assembled_data.data = retranslated\n                if self.theory == 'no':\n                    poolingfinish = self.call_function_repeatedly(restructuredlib, self.library, 'linear_encoding')\n                    retranslated = back_translate_nested_list_poly_binom_real(poolingfinish, self.library)\n                    assembled_data.data = retranslated\n\n            # positional assembly / binomial encoding\n            elif self.assembly_structure == 'positional_assembly' and self.encoding_scheme == 'binomial_encoding':\n                restructuredlib = translate_nested_list_poly(encoded_data.data, self.library)\n                if self.theory == 'yes':\n                    poolingfinish = self.call_function_repeatedly_therory(restructuredlib, self.library, 'binomial_encoding')\n\n                    retranslated = back_translate_nested_list_poly_binom(poolingfinish, self.library)\n                    retranslated = flatten_at_layer(retranslated, 1)\n                    assembled_data.data = retranslated\n                elif self.theory == 'no':\n                    poolingfinish = self.call_function_repeatedly(restructuredlib, self.library, 'binomial_encoding')\n\n                    retranslated = back_translate_nested_list_poly_binom_real(poolingfinish, self.library)\n                    assembled_data.data = retranslated\n\n            info = {}\n\n            return assembled_data, info\n\n        else: \n            raise ValueError(\"Data object is not supported.\")\n\n\n    def substitute_tuples_with_oligos(self, nested_list):\n        for i in range(len(nested_list)):\n            if isinstance(nested_list[i], tuple):\n                nested_list[i] = Oligo(motifs=nested_list[i])\n            elif isinstance(nested_list[i], list):\n                nested_list[i] = self.substitute_tuples_with_oligos(nested_list[i])\n            else:\n                raise ValueError(\"Invalid data structure.\")\n        return nested_list\n\n\n    def recursive_assembly(self, nested_list, mean, std_dev, hybridisation_steps):\n        \"\"\"\n        Recursively assemble the data using the pool of oligos.\n        \"\"\"\n        for item in nested_list:\n\n            if all(isinstance(item, Oligo) for item in nested_list):\n                combined_pool = OligoPool(oligo_list=nested_list, mean=self.mean, std_dev=self.std_dev)\n                combined_pool.hybridise(hybridisation_steps)\n                return combined_pool\n\n            elif all(isinstance(item, OligoPool) or isinstance(item, Oligo) for item in nested_list):\n                combined_pool = OligoPool.join(nested_list, mean=self.mean, std_dev=self.std_dev)\n                combined_pool.hybridise(hybridisation_steps)\n                return combined_pool\n\n            else:\n                for i in range(len(nested_list)):\n                    if isinstance(nested_list[i], list):\n                        nested_list[i] = self.recursive_assembly(nested_list[i], mean, std_dev, hybridisation_steps)\n\n                combined_pool = OligoPool([]).join(pools=nested_list, mean=mean, std_dev=std_dev)\n                combined_pool.hybridise(hybridisation_steps)\n                return combined_pool\n\n\n    def find_depth(self, nested_list):\n        if not isinstance(nested_list, list):\n            return 0\n        elif not nested_list:\n            return 1\n        else:\n            return 1 + max(self.find_depth(item) for item in nested_list)\n\n\n    def call_function_repeatedly(self,nested_list,library,encoding):\n        if encoding == 'binomial_encoding' and library.structure == 'positional_assembly':\n\n            polypooling = self.recursive_assembly_theoretical_withmean(nested_list,library, mean=self.mean)\n\n\n            times = self.find_depth(polypooling)\n            for i in range(times):\n                polypooling = self.recursive_assembly_messy_randompairing(polypooling,library)\n\n\n        elif encoding == 'linear_encoding' and library.structure == 'positional_assembly':\n            polypooling = self.recursive_assembly_theoretical_withmean(nested_list,library, mean=self.mean)\n\n            times = self.find_depth(polypooling)\n\n            for i in range(times):\n                polypooling = self.recursive_assembly_messy_randompairing(polypooling,library)\n\n        elif encoding == 'binomial_encoding' and library.structure == 'linear_assembly':\n            times = self.find_depth(nested_list)\n\n            polypooling = nested_list\n            for i in range(times):\n                polypooling = self.recursive_assembly_messy_randompairing(polypooling,library)\n\n        elif encoding == 'linear_encoding' and library.structure == 'linear_assembly':\n\n            times = self.find_depth(nested_list)\n            polypooling = nested_list\n            for i in range(times-1):\n                polypooling = self.recursive_assembly_messy_randompairing(polypooling,library)\n\n        return polypooling\n\n\n    def recursive_assembly_messy_randompairing(self,nested_list,library):\n        counter = 0\n\n        if all(isinstance(subitem, Oligo) for subitem in nested_list) and len(nested_list)&gt;1:\n            combined_pool = OligoPool([]).join(pools=nested_list, mean=self.mean, std_dev=self.std_dev)\n\n            tester=0\n            checkup = []\n            newoligos = []\n            looping = True\n            while looping:\n                leftends = []\n                rightends = []\n\n                if newoligos != []:\n                    combined_pool = OligoPool([]).join(pools=newoligos, mean=1, std_dev=0)\n                if  len(combined_pool.pool) == 0:\n                    break\n\n                newoligos = []\n                for i in range(len(combined_pool.pool)):\n\n                    allinpool = combined_pool.pool[i]\n                    allends = [allinpool.end('r','5'),allinpool.end('f','5'),allinpool.end('r','3'),allinpool.end('f','3')]\n                    allvelidends = [item for item in allends if item is not None]\n\n                    for item in allvelidends:\n                        leftends.append([i,item])\n                    newoligos.append(allinpool)\n\n                leftends = sorted(leftends, key=lambda x: x[1])\n                leftends = [list(group) for key, group in groupby(leftends, key=lambda x: x[1])]\n\n                tester =+ 1\n                motivrcounter = 0\n\n                if len(checkup) == 0:\n                    findingmotive = leftends[motivrcounter][0][1]\n                    checkup.append(leftends[motivrcounter][0][1])\n                    if '*' in leftends[motivrcounter][0][1]:\n                        checkup.append(leftends[motivrcounter][0][1][:-1])\n                        findingmotivecomp = leftends[motivrcounter][0][1][:-1]\n                    else:\n                        checkup.append(leftends[motivrcounter][0][1]+'*')\n                        findingmotivecomp = leftends[motivrcounter][0][1]+'*'\n                    motivrcounter+=1\n                else:\n                    while findingmotive in checkup:\n\n                        findingmotive = leftends[motivrcounter][0][1]\n                        motivrcounter+=1\n\n                        if motivrcounter == len(leftends)-1:\n\n                            looping = False\n                            motivrcounter =-1\n                            break\n                    motivrcounter-=1\n                    if '*' in leftends[motivrcounter][0][1]:\n                        checkup.append(leftends[motivrcounter][0][1])  \n                        checkup.append(leftends[motivrcounter][0][1][:-1]) \n                        findingmotivecomp = leftends[motivrcounter][0][1][:-1]  \n                    else:\n                        checkup.append(leftends[motivrcounter][0][1])\n                        checkup.append(leftends[motivrcounter][0][1]+'*')\n                        findingmotivecomp = leftends[motivrcounter][0][1]+'*'\n                    motivrcounter+=1\n                sublist1 = None\n                sublist2 = None\n\n                for sublist in leftends:\n                    if all(item[1] == findingmotive for item in sublist):\n                        sublist1 = sublist\n                    elif all(item[1] == findingmotivecomp for item in sublist):\n                        sublist2 = sublist   \n\n                if sublist1 == None:\n                    lensublist1=0\n                else:\n                    lensublist1 = len(sublist1)\n                if sublist2 == None:\n                    lensublist2=0\n                else:\n                    lensublist2 = len(sublist2)\n                    random.shuffle(sublist2)\n\n                newoligosupdated = []\n                deletableoligos = []\n                for j in range(min(lensublist1,lensublist2)):\n\n                    temp_pool = OligoPool([newoligos[sublist1[j][0]],newoligos[sublist2[j][0]]])\n                    deletableoligos.append(newoligos[sublist1[j][0]])\n                    deletableoligos.append(newoligos[sublist2[j][0]])\n                    newoligotoadd = temp_pool.hybridise(1,library)\n                    newoligos.append(newoligotoadd)\n\n                elements_count = {element: deletableoligos.count(element) for element in set(deletableoligos)}\n\n                result_list = []\n                for item in newoligos:\n                    if item in elements_count and elements_count[item] &gt; 0:\n                        elements_count[item] -= 1\n                    else:\n                        result_list.append(item)\n                newoligos = result_list\n\n            combined_pool = OligoPool([]).join(pools=newoligos, mean=1, std_dev=0)\n            return combined_pool\n\n        elif all(isinstance(subitem, OligoPool) or isinstance(subitem, Oligo)  for subitem in nested_list)  and len(nested_list)&gt;1:\n            combined_pool = OligoPool([]).join(pools=nested_list, mean=self.mean, std_dev=self.std_dev)\n            tester = 0\n            checkup = []\n            newoligos = []\n            looping = True\n\n            while looping:\n                leftends = []\n                rightends = []\n                if newoligos != []:\n                    combined_pool = OligoPool([]).join(pools=newoligos, mean=1, std_dev=0)\n\n                newoligos = []\n                for i in range(len(combined_pool.pool)):\n\n                    if isinstance(combined_pool.pool[i], OligoPool):\n                        for allinpool in combined_pool.pool[i].pool:\n                            allends = [allinpool.end('r','5'),allinpool.end('f','5'),allinpool.end('r','3'),allinpool.end('f','3')]\n                            allvelidends = [item for item in allends if item is not None]\n\n                            for item in allvelidends:\n                                leftends.append([i,item])\n\n                            newoligos.append(allinpool)\n\n\n                    else:\n                        allinpool = combined_pool.pool[i]\n                        allends = [allinpool.end('r','5'),allinpool.end('f','5'),allinpool.end('r','3'),allinpool.end('f','3')]\n                        allvelidends = [item for item in allends if item is not None]\n                        for item in allvelidends:\n                            leftends.append([i,item])\n                        newoligos.append(allinpool)\n\n                leftends = sorted(leftends, key=lambda x: x[1])\n                leftends = [list(group) for key, group in groupby(leftends, key=lambda x: x[1])]\n\n                tester =+ 1\n                motivrcounter = 0\n\n                if len(checkup) == 0:\n                    findingmotive = leftends[motivrcounter][0][1]\n                    checkup.append(leftends[motivrcounter][0][1])\n                    if '*' in leftends[motivrcounter][0][1]:\n                        checkup.append(leftends[motivrcounter][0][1][:-1])\n                        findingmotivecomp = leftends[motivrcounter][0][1][:-1]\n                    else:\n                        checkup.append(leftends[motivrcounter][0][1]+'*')\n                        findingmotivecomp = leftends[motivrcounter][0][1]+'*'\n                    motivrcounter+=1\n                else:\n                    while findingmotive in checkup:\n\n                        findingmotive = leftends[motivrcounter][0][1]\n                        motivrcounter+=1\n\n                        if motivrcounter == len(leftends)-1:\n\n                            looping = False\n                            motivrcounter =-1\n                            break\n                    motivrcounter-=1\n                    if '*' in leftends[motivrcounter][0][1]:\n                        checkup.append(leftends[motivrcounter][0][1])  \n                        checkup.append(leftends[motivrcounter][0][1][:-1]) \n                        findingmotivecomp = leftends[motivrcounter][0][1][:-1]  \n                    else:\n                        checkup.append(leftends[motivrcounter][0][1])\n                        checkup.append(leftends[motivrcounter][0][1]+'*')\n                        findingmotivecomp = leftends[motivrcounter][0][1]+'*'\n                    motivrcounter+=1\n                sublist1 = None\n                sublist2 = None\n\n                for sublist in leftends:\n                    if all(item[1] == findingmotive for item in sublist):\n                        sublist1 = sublist\n                    elif all(item[1] == findingmotivecomp for item in sublist):\n                        sublist2 = sublist   \n\n                if sublist1 == None:\n                    lensublist1=0\n                else:\n                    lensublist1 = len(sublist1)\n                if sublist2 == None:\n                    lensublist2=0\n                else:\n                    lensublist2 = len(sublist2)\n                    random.shuffle(sublist2)\n\n                newoligosupdated = []\n                deletableoligos = []\n                for j in range(min(lensublist1,lensublist2)):\n\n                    temp_pool = OligoPool([newoligos[sublist1[j][0]],newoligos[sublist2[j][0]]])\n                    deletableoligos.append(newoligos[sublist1[j][0]])\n                    deletableoligos.append(newoligos[sublist2[j][0]])\n                    newoligotoadd = temp_pool.hybridise(1,library)\n                    newoligos.append(newoligotoadd)\n\n                elements_count = {element: deletableoligos.count(element) for element in set(deletableoligos)}\n\n                result_list = []\n                for item in newoligos:\n                    if item in elements_count and elements_count[item] &gt; 0:\n                        elements_count[item] -= 1\n                    else:\n                        result_list.append(item)\n                newoligos = result_list\n\n            combined_pool = OligoPool([]).join(pools=newoligos, mean=1, std_dev=0)\n            return combined_pool\n\n        elif len(nested_list)==1:\n            return nested_list[0]\n        else:\n            return [self.recursive_assembly_messy_randompairing(subelement,library) if isinstance(subelement, list) else subelement for subelement in nested_list]\n\n\n    def recursive_assembly_messy(self,nested_list,library):\n        counter=0\n\n        if all(isinstance(subitem, Oligo) for subitem in nested_list) and len(nested_list)&gt;1:\n            combined_pool = OligoPool(oligo_list=nested_list, mean=self.mean, std_dev=self.std_dev)\n            combined_pool.hybridise(self.hybridisation_steps,library)\n            return combined_pool\n\n        elif all(isinstance(subitem, OligoPool) or isinstance(subitem, Oligo)  for subitem in nested_list)  and len(nested_list)&gt;1:\n            combined_pool = OligoPool([]).join(pools=nested_list, mean=self.mean, std_dev=self.std_dev)\n            combined_pool.hybridise(self.hybridisation_steps,library)\n            return combined_pool\n\n        elif len(nested_list)==1:\n            return nested_list[0]\n        else:\n\n            return [self.recursive_assembly_messy(subelement,library) if isinstance(subelement, list) else subelement for subelement in nested_list]\n\n\n    def call_function_repeatedly_therory(self,nested_list,library,encoding):\n        \"\"\"\n        Calls the target function the specified number of times.\n\n        :param target_function: The function to be called repeatedly.\n        :param times: The number of times to call the function.\n        :param args: Positional arguments to pass to the target function.\n        :param kwargs: Keyword arguments to pass to the target function.\n        \"\"\"\n        times=self.find_depth(nested_list)\n\n        if encoding=='linear_encoding' and library.structure==\"linear_assembly\":\n            for i in range(times-1):\n\n                nested_list=self.recursive_assembly_chain_theoretical(nested_list,library)\n\n        elif encoding=='binomial_encoding' and library.structure==\"linear_assembly\":\n            for i in range(times-2):\n\n                nested_list=self.recursive_assembly_theoretical(nested_list,library)\n\n        elif (encoding=='linear_encoding' and library.structure==\"positional_assembly\"):\n            for i in range(times-1):\n\n                nested_list=self.recursive_assembly_theoretical(nested_list,library)\n\n        elif (encoding=='binomial_encoding' and library.structure==\"positional_assembly\"):\n            for i in range(times-2):\n                nested_list=self.recursive_assembly_theoretical(nested_list,library)\n\n        return nested_list\n\n\n    def recursive_assembly_theoretical_withmean(self,nested_list,library,mean):\n        counter=0\n\n        if all(isinstance(subitem, Oligo) for subitem in nested_list) and len(nested_list)&gt;1:\n\n            alloligos = []\n            for i in range(int(mean)):\n                hybridized=nested_list[0]\n                hybridizationpool=OligoPool([hybridized,nested_list[1]])\n                hybridized=hybridizationpool.hybridise(1,library)\n\n                for i in range(len(nested_list)-2):\n                    hybridizationpool=OligoPool([]).join([hybridized,nested_list[i+2]],mean=1, std_dev=0)\n\n                    hybridized=hybridizationpool.hybridise(1,library)\n                alloligos.append(hybridized)\n            hybridizedpool = OligoPool(alloligos)\n\n            return hybridizedpool\n\n        elif all(isinstance(subitem, OligoPool) or isinstance(subitem, Oligo)  for subitem in nested_list)  and len(nested_list)&gt;1:\n            hybridized=nested_list[0]\n\n            combined_pool = OligoPool([]).join([hybridized,nested_list[1]], mean=mean, std_dev=0)\n            hybridized=combined_pool.hybridise(1,library)\n            for i in range(len(nested_list)-2):\n                hybridizationpool=OligoPool([]).join([hybridized,nested_list[i+2]], mean=mean, std_dev=0)\n                hybridized=hybridizationpool.hybridise(1,library)\n            return hybridized\n\n        elif len(nested_list)==1:\n            return nested_list[0]\n        else:\n\n\n            return [self.recursive_assembly_theoretical_withmean(subelement,library,mean) if isinstance(subelement, list) else subelement for subelement in nested_list]\n\n\n    def recursive_assembly_theoretical(self,nested_list,library):\n        counter=0\n\n        if all(isinstance(subitem, Oligo) for subitem in nested_list) and len(nested_list)&gt;1:\n\n            hybridized=nested_list[0]\n            hybridizationpool=OligoPool([hybridized,nested_list[1]])\n            hybridized=hybridizationpool.hybridise(1,library)\n\n            for i in range(len(nested_list)-2):\n                hybridizationpool=OligoPool([]).join([hybridized,nested_list[i+2]], mean=1, std_dev=0)\n\n                hybridized=hybridizationpool.hybridise(1,library)\n                if counter==0:\n\n                    counter+=1\n            counter2=0\n\n            return hybridized\n\n        elif all(isinstance(subitem, OligoPool) or isinstance(subitem, Oligo)  for subitem in nested_list)  and len(nested_list)&gt;1:\n\n            hybridized=nested_list[0]\n\n            combined_pool = OligoPool([]).join([hybridized,nested_list[1]], mean=1, std_dev=0)\n            hybridized=combined_pool.hybridise(1,library)\n            for i in range(len(nested_list)-2):\n                hybridizationpool=OligoPool([]).join([hybridized,nested_list[i+2]], mean=1, std_dev=0)\n                hybridized=hybridizationpool.hybridise(1,library)\n            return hybridized\n\n        elif len(nested_list)==1:\n            return nested_list[0]\n        else:\n            return [self.recursive_assembly_theoretical(subelement,library) if isinstance(subelement, list) else subelement for subelement in nested_list]\n\n\n    def recursive_assembly_chain_theoretical(self,nested_list,library):\n        counter=0\n\n        if all(isinstance(subitem, Oligo) for subitem in nested_list):\n\n            hybridized=nested_list[0]\n\n            endoligo = Oligo([complement(nested_list[0].motifs[0],library.dictmotives),'empty'])\n\n            hybridizedend=OligoPool([hybridized,endoligo])\n            hybridized=hybridizedend.hybridise(1,library)\n            hybridizationpool=OligoPool([]).join([hybridized,nested_list[1]], mean=1, std_dev=0)\n            hybridized=hybridizationpool.hybridise(1,library)\n            for i in range(len(nested_list)-2):\n                hybridizationpool=OligoPool([]).join([hybridized,nested_list[i+2]], mean=1, std_dev=0)\n                hybridized=hybridizationpool.hybridise(1,library)\n                if counter==0:\n\n                    counter+=1\n\n            return hybridized\n\n        elif all(isinstance(subitem, OligoPool) or isinstance(subitem, Oligo)  for subitem in nested_list):\n            hybridized=nested_list[0]\n\n            combined_pool = OligoPool([]).join([hybridized,nested_list[1]], mean=1, std_dev=0)\n            hybridized=combined_pool.hybridise(1,library)\n            for i in range(len(nested_list)-2):\n                hybridizationpool=OligoPool([]).join([hybridized,nested_list[i+2]], mean=1, std_dev=0)\n                hybridized=hybridizationpool.hybridise(1,library)\n            return hybridized\n        else:\n            return [self.recursive_assembly_chain_theoretical(subelement,library) if isinstance(subelement, list) else subelement for subelement in nested_list]\n\n\n    def recursive_assembly_messy_randompairing_chain(self,nested_list,library):\n        if all(isinstance(subitem, Oligo) for subitem in nested_list) and len(nested_list)&gt;1:\n            combined_pool = OligoPool([]).join(pools=nested_list, mean=self.mean, std_dev=self.std_dev)\n            tester=0\n            checkup = []\n            newoligos = []\n            looping = True\n            while looping:\n                leftends = []\n                rightends = []\n                if newoligos != []:\n                    combined_pool = OligoPool([]).join(pools=newoligos, mean=1, std_dev=0)\n\n                newoligos = []\n                for i in range(len(combined_pool.pool)):\n\n                    # else:\n                    allinpool = combined_pool.pool[i]\n                    allends = [allinpool.end('r','5'),allinpool.end('f','5'),allinpool.end('r','3'),allinpool.end('f','3')]\n                    allvelidends = [item for item in allends if (item is not None)]\n                    for item in allvelidends:\n                        leftends.append([i,item])\n                    newoligos.append(allinpool)\n\n                leftends = sorted(leftends, key=lambda x: x[1])\n                leftends = [list(group) for key, group in groupby(leftends, key=lambda x: x[1])]\n\n                tester =+ 1\n                motivrcounter = 0\n\n                if len(checkup) == 0:\n                    findingmotive = leftends[motivrcounter][0][1]\n                    checkup.append(leftends[motivrcounter][0][1])\n                    if '*' in leftends[motivrcounter][0][1]:\n                        checkup.append(leftends[motivrcounter][0][1][:-1])\n                        findingmotivecomp = leftends[motivrcounter][0][1][:-1]\n                    else:\n                        checkup.append(leftends[motivrcounter][0][1]+'*')\n                        findingmotivecomp = leftends[motivrcounter][0][1]+'*'\n                    motivrcounter+=1\n                else:\n                    while findingmotive in checkup:\n\n                        findingmotive = leftends[motivrcounter][0][1]\n                        motivrcounter+=1\n\n                        if motivrcounter == len(leftends)-1:\n\n                            looping = False\n                            motivrcounter =-1\n                            break\n                    motivrcounter-=1\n                    if '*' in leftends[motivrcounter][0][1]:\n                        checkup.append(leftends[motivrcounter][0][1])  \n                        checkup.append(leftends[motivrcounter][0][1][:-1]) \n                        findingmotivecomp = leftends[motivrcounter][0][1][:-1]  \n                    else:\n                        checkup.append(leftends[motivrcounter][0][1])\n                        checkup.append(leftends[motivrcounter][0][1]+'*')\n                        findingmotivecomp = leftends[motivrcounter][0][1]+'*'\n                    motivrcounter+=1\n                sublist1 = None\n                sublist2 = None\n\n                for sublist in leftends:\n                    if all(item[1] == findingmotive for item in sublist):\n                        sublist1 = sublist\n                    elif all(item[1] == findingmotivecomp for item in sublist):\n                        sublist2 = sublist   \n\n                if sublist1 == None:\n                    lensublist1=0\n                else:\n                    lensublist1 = len(sublist1)\n                if sublist2 == None:\n                    lensublist2=0\n                else:\n                    lensublist2 = len(sublist2)\n                    random.shuffle(sublist2)\n\n                newoligosupdated = []\n                deletableoligos = []\n                for j in range(min(lensublist1,lensublist2)):\n\n                    temp_pool = OligoPool([newoligos[sublist1[j][0]],newoligos[sublist2[j][0]]])\n                    deletableoligos.append(newoligos[sublist1[j][0]])\n                    deletableoligos.append(newoligos[sublist2[j][0]])\n                    newoligotoadd = temp_pool.hybridise(1,library)\n                    newoligos.append(newoligotoadd)\n\n                elements_count = {element: deletableoligos.count(element) for element in set(deletableoligos)}\n\n                result_list = []\n                for item in newoligos:\n                    if item in elements_count and elements_count[item] &gt; 0:\n                        elements_count[item] -= 1\n                    else:\n                        result_list.append(item)\n                newoligos = result_list\n\n            combined_pool = OligoPool([]).join(pools=newoligos, mean=1, std_dev=0)\n            return combined_pool\n\n        elif all(isinstance(subitem, OligoPool) or isinstance(subitem, Oligo)  for subitem in nested_list)  and len(nested_list)&gt;1:\n            combined_pool = OligoPool([]).join(pools=nested_list, mean=self.mean, std_dev=self.std_dev)\n            tester=0\n            checkup = []\n            newoligos = []\n            looping = True\n            while looping:\n                leftends = []\n                rightends = []\n                if newoligos != []:\n                    combined_pool = OligoPool([]).join(pools=newoligos, mean=1, std_dev=0)\n\n                newoligos = []\n                for i in range(len(combined_pool.pool)):\n\n                    if isinstance(combined_pool.pool[i], OligoPool):\n                        for allinpool in combined_pool.pool[i].pool:\n                            allends = [allinpool.end('r','5'),allinpool.end('f','5'),allinpool.end('r','3'),allinpool.end('f','3')]\n                            allvelidends = [item for item in allends if item is not None]\n                            for item in allvelidends:\n                                leftends.append([i,item])\n\n                            newoligos.append(allinpool)\n\n\n                    else:\n                        allinpool = combined_pool.pool[i]\n                        allends = [allinpool.end('r','5'),allinpool.end('f','5'),allinpool.end('r','3'),allinpool.end('f','3')]\n\n                        allvelidends = [item for item in allends if (item is not None)]\n                        for item in allvelidends:\n                            leftends.append([i,item])\n                        newoligos.append(allinpool)\n\n                leftends = sorted(leftends, key=lambda x: x[1])\n                leftends = [list(group) for key, group in groupby(leftends, key=lambda x: x[1])]\n                tester =+ 1\n                motivrcounter = 0\n\n                if len(checkup) == 0:\n                    findingmotive = leftends[motivrcounter][0][1]\n                    checkup.append(leftends[motivrcounter][0][1])\n                    if '*' in leftends[motivrcounter][0][1]:\n                        checkup.append(leftends[motivrcounter][0][1][:-1])\n                        findingmotivecomp = leftends[motivrcounter][0][1][:-1]\n                    else:\n                        checkup.append(leftends[motivrcounter][0][1]+'*')\n                        findingmotivecomp = leftends[motivrcounter][0][1]+'*'\n                    motivrcounter+=1\n                else:\n                    while findingmotive in checkup:\n\n                        findingmotive = leftends[motivrcounter][0][1]\n                        motivrcounter+=1\n\n                        if motivrcounter == len(leftends)-1:\n\n                            looping = False\n                            motivrcounter =-1\n                            break\n                    motivrcounter-=1\n                    if '*' in leftends[motivrcounter][0][1]:\n                        checkup.append(leftends[motivrcounter][0][1])  \n                        checkup.append(leftends[motivrcounter][0][1][:-1]) \n                        findingmotivecomp = leftends[motivrcounter][0][1][:-1]  \n                    else:\n                        checkup.append(leftends[motivrcounter][0][1])\n                        checkup.append(leftends[motivrcounter][0][1]+'*')\n                        findingmotivecomp = leftends[motivrcounter][0][1]+'*'\n                    motivrcounter+=1\n                sublist1 = None\n                sublist2 = None\n\n                for sublist in leftends:\n                    if all(item[1] == findingmotive for item in sublist):\n                        sublist1 = sublist\n                    elif all(item[1] == findingmotivecomp for item in sublist):\n                        sublist2 = sublist   \n\n                if sublist1 == None:\n                    lensublist1=0\n                else:\n                    lensublist1 = len(sublist1)\n                if sublist2 == None:\n                    lensublist2=0\n                else:\n                    lensublist2 = len(sublist2)\n                    random.shuffle(sublist2)\n\n                newoligosupdated = []\n                deletableoligos = []\n                for j in range(min(lensublist1,lensublist2)):\n\n                    temp_pool = OligoPool([newoligos[sublist1[j][0]],newoligos[sublist2[j][0]]])\n                    deletableoligos.append(newoligos[sublist1[j][0]])\n                    deletableoligos.append(newoligos[sublist2[j][0]])\n                    newoligotoadd = temp_pool.hybridise(1,library)\n                    newoligos.append(newoligotoadd)\n\n                elements_count = {element: deletableoligos.count(element) for element in set(deletableoligos)}\n\n                result_list = []\n                for item in newoligos:\n                    if item in elements_count and elements_count[item] &gt; 0:\n                        elements_count[item] -= 1\n                    else:\n                        result_list.append(item)\n                newoligos = result_list\n\n            combined_pool = OligoPool([]).join(pools=newoligos, mean=1, std_dev=0)\n            return combined_pool\n\n        elif len(nested_list)==1:\n            return nested_list[0]\n        else:\n\n            return [self.recursive_assembly_messy_randompairing_chain(subelement,library) if isinstance(subelement, list) else subelement for subelement in nested_list]\n</code></pre>"},{"location":"reference/#dnabyte.assembly.SimulateAssembly.call_function_repeatedly_therory","title":"<code>call_function_repeatedly_therory(nested_list, library, encoding)</code>","text":"<p>Calls the target function the specified number of times.</p> <p>:param target_function: The function to be called repeatedly. :param times: The number of times to call the function. :param args: Positional arguments to pass to the target function. :param kwargs: Keyword arguments to pass to the target function.</p> Source code in <code>dnabyte/assembly.py</code> <pre><code>def call_function_repeatedly_therory(self,nested_list,library,encoding):\n    \"\"\"\n    Calls the target function the specified number of times.\n\n    :param target_function: The function to be called repeatedly.\n    :param times: The number of times to call the function.\n    :param args: Positional arguments to pass to the target function.\n    :param kwargs: Keyword arguments to pass to the target function.\n    \"\"\"\n    times=self.find_depth(nested_list)\n\n    if encoding=='linear_encoding' and library.structure==\"linear_assembly\":\n        for i in range(times-1):\n\n            nested_list=self.recursive_assembly_chain_theoretical(nested_list,library)\n\n    elif encoding=='binomial_encoding' and library.structure==\"linear_assembly\":\n        for i in range(times-2):\n\n            nested_list=self.recursive_assembly_theoretical(nested_list,library)\n\n    elif (encoding=='linear_encoding' and library.structure==\"positional_assembly\"):\n        for i in range(times-1):\n\n            nested_list=self.recursive_assembly_theoretical(nested_list,library)\n\n    elif (encoding=='binomial_encoding' and library.structure==\"positional_assembly\"):\n        for i in range(times-2):\n            nested_list=self.recursive_assembly_theoretical(nested_list,library)\n\n    return nested_list\n</code></pre>"},{"location":"reference/#dnabyte.assembly.SimulateAssembly.nest_list","title":"<code>nest_list(lst)</code>","text":"<p>Recursively nests a list into the structure [[[[a, b], c], d], e].</p> <p>Parameters:</p> Name Type Description Default <code>lst</code> <code>list</code> <p>The input list to be nested.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>The nested list structure.</p> Source code in <code>dnabyte/assembly.py</code> <pre><code>def nest_list(self, lst):\n    \"\"\"\n    Recursively nests a list into the structure [[[[a, b], c], d], e].\n\n    Args:\n        lst (list): The input list to be nested.\n\n    Returns:\n        list: The nested list structure.\n    \"\"\"\n    if len(lst) &lt;= 1:\n        return lst  # Base case: if the list has 1 or fewer elements, return it as is\n    return [self.nest_list(lst[:-1]), lst[-1]]  # Recursively nest all but the last element with the last element\n</code></pre>"},{"location":"reference/#dnabyte.assembly.SimulateAssembly.print_list_structure","title":"<code>print_list_structure(lst, level=0)</code>","text":"<p>Recursively prints the structure of a list of lists.</p> <p>Parameters:</p> Name Type Description Default <code>lst</code> <code>list</code> <p>The list to analyze.</p> required <code>level</code> <code>int</code> <p>The current nesting level (used for indentation).</p> <code>0</code> Source code in <code>dnabyte/assembly.py</code> <pre><code>def print_list_structure(self, lst, level=0):\n    \"\"\"\n    Recursively prints the structure of a list of lists.\n\n    Args:\n        lst (list): The list to analyze.\n        level (int): The current nesting level (used for indentation).\n    \"\"\"\n    if isinstance(lst, list):\n        print(\"  \" * level + f\"Level {level}: List with {len(lst)} elements\")\n        for item in lst:\n            self.print_list_structure(item, level + 1)\n    else:\n        if isinstance(lst, Oligo):\n            print(\"  \" * level + f\"Level {level}: {type(lst).__name__} ({lst})\")\n        elif isinstance(lst, OligoPool):\n            for oligo in lst.pool:\n                print(\"  \" * level + f\"Level {level}: {type(oligo).__name__} ({oligo})\")\n</code></pre>"},{"location":"reference/#dnabyte.assembly.SimulateAssembly.recursive_assembly","title":"<code>recursive_assembly(nested_list, mean, std_dev, hybridisation_steps)</code>","text":"<p>Recursively assemble the data using the pool of oligos.</p> Source code in <code>dnabyte/assembly.py</code> <pre><code>def recursive_assembly(self, nested_list, mean, std_dev, hybridisation_steps):\n    \"\"\"\n    Recursively assemble the data using the pool of oligos.\n    \"\"\"\n    for item in nested_list:\n\n        if all(isinstance(item, Oligo) for item in nested_list):\n            combined_pool = OligoPool(oligo_list=nested_list, mean=self.mean, std_dev=self.std_dev)\n            combined_pool.hybridise(hybridisation_steps)\n            return combined_pool\n\n        elif all(isinstance(item, OligoPool) or isinstance(item, Oligo) for item in nested_list):\n            combined_pool = OligoPool.join(nested_list, mean=self.mean, std_dev=self.std_dev)\n            combined_pool.hybridise(hybridisation_steps)\n            return combined_pool\n\n        else:\n            for i in range(len(nested_list)):\n                if isinstance(nested_list[i], list):\n                    nested_list[i] = self.recursive_assembly(nested_list[i], mean, std_dev, hybridisation_steps)\n\n            combined_pool = OligoPool([]).join(pools=nested_list, mean=mean, std_dev=std_dev)\n            combined_pool.hybridise(hybridisation_steps)\n            return combined_pool\n</code></pre>"},{"location":"reference/#dnabyte.storage.SimulateStorage","title":"<code>SimulateStorage</code>","text":"<p>Simulate storage of DNA sequences in a storage medium.</p> <p>The class consists of a constructor, which sets the parameters of the storage simulation,  and a simulate method, which applies the simulation to an object of the AssembledData class.</p> <p>:param years: The number of years for which DNA storage is supposed to be simulated. (0 to perform no simulation) :param storage_conditions: A string 'permafrost', or 'room_temperature', or 'biogene'. (None to perform no simulation)</p> Source code in <code>dnabyte/storage.py</code> <pre><code>class SimulateStorage:\n    \"\"\"\n    Simulate storage of DNA sequences in a storage medium.\n\n    The class consists of a constructor, which sets the parameters of the storage simulation, \n    and a simulate method, which applies the simulation to an object of the AssembledData class.\n\n    :param years: The number of years for which DNA storage is supposed to be simulated. (0 to perform no simulation)\n    :param storage_conditions: A string 'permafrost', or 'room_temperature', or 'biogene'. (None to perform no simulation)\n    \"\"\"\n    def __init__(self, params, logger=None):\n\n        self.years = params.years\n        self.storage_conditions = params.storage_conditions\n\n    def simulate(self, assembled_data):\n        \"\"\"\n        Simulate storage of DNA sequences in a storage medium.\n\n        :param assembled_data: An object of class AssembledData.\n        :return: A list of stored DNA sequences.\n        \"\"\"\n\n        if self.storage_conditions == None or self.years == 0:\n            stored_data = StoredData(assembled_data=assembled_data.data)\n            strand_breaks = 0\n\n        elif self.storage_conditions == 'random':\n            holder = []\n            for oligo in assembled_data.data:\n                for i in range(0, math.ceil(len(oligo[0])/460)):\n                    bases = ['A', 'T', 'C', 'G']\n                    randomposition = random.randint(0, len(oligo[0])-1)\n                    randombase = random.choice(bases)\n                    oligo[0] = oligo[0][:randomposition] + randombase + oligo[0][randomposition+1:]\n                holder.append([oligo[0], oligo[1]])\n                strand_breaks = math.ceil(len(oligo[0])/460)\n\n            stored_data = StoredData(assembled_data=holder)\n\n        else:\n            if isinstance(assembled_data, AssembledData):\n                data = assembled_data.data\n                #scaled_data = [item for item in data for _ in range(self.scale)]\n                remaining_oligos = []\n                #for oligo in scaled_data:\n\n                counter = 0\n\n                for oligo in data:\n\n                # Probability of decay per oligo equals 1 minus the probability that not a single nucleotide decayed\n                    if self.storage_conditions == 'permafrost':\n                        decay_probability = 1 - (1 - 5.5E-6)**(len(oligo)*self.years)\n                    elif self.storage_conditions == 'biogene':\n                        decay_probability = 1 - (1 - 1E-7)**(len(oligo)*self.years)\n\n                    else: \n                        decay_probability = 1 - (1 - 5E-3)**(len(oligo)*self.years)\n\n                    rndm = random.random()\n\n                    if rndm &gt; decay_probability:\n                        remaining_oligos.append(oligo)\n                    else:\n                        counter += 1\n\n                    strand_breaks = counter\n                    # Approach, where every oligo has an equal probability of decay\n                    # N_t = len(data) * math.exp(-decay_probability * self.years)\n                    # remaining_oligos = random.sample(data, int(round(N_t)))\n\n                stored_data = StoredData(assembled_data=remaining_oligos)\n\n            else: \n                raise ValueError(\"The input data is not an instance of StoredData.\")\n\n        info = {}\n        info['number_of_strand_breaks'] = strand_breaks\n\n        return stored_data, info\n</code></pre>"},{"location":"reference/#dnabyte.storage.SimulateStorage.simulate","title":"<code>simulate(assembled_data)</code>","text":"<p>Simulate storage of DNA sequences in a storage medium.</p> <p>:param assembled_data: An object of class AssembledData. :return: A list of stored DNA sequences.</p> Source code in <code>dnabyte/storage.py</code> <pre><code>def simulate(self, assembled_data):\n    \"\"\"\n    Simulate storage of DNA sequences in a storage medium.\n\n    :param assembled_data: An object of class AssembledData.\n    :return: A list of stored DNA sequences.\n    \"\"\"\n\n    if self.storage_conditions == None or self.years == 0:\n        stored_data = StoredData(assembled_data=assembled_data.data)\n        strand_breaks = 0\n\n    elif self.storage_conditions == 'random':\n        holder = []\n        for oligo in assembled_data.data:\n            for i in range(0, math.ceil(len(oligo[0])/460)):\n                bases = ['A', 'T', 'C', 'G']\n                randomposition = random.randint(0, len(oligo[0])-1)\n                randombase = random.choice(bases)\n                oligo[0] = oligo[0][:randomposition] + randombase + oligo[0][randomposition+1:]\n            holder.append([oligo[0], oligo[1]])\n            strand_breaks = math.ceil(len(oligo[0])/460)\n\n        stored_data = StoredData(assembled_data=holder)\n\n    else:\n        if isinstance(assembled_data, AssembledData):\n            data = assembled_data.data\n            #scaled_data = [item for item in data for _ in range(self.scale)]\n            remaining_oligos = []\n            #for oligo in scaled_data:\n\n            counter = 0\n\n            for oligo in data:\n\n            # Probability of decay per oligo equals 1 minus the probability that not a single nucleotide decayed\n                if self.storage_conditions == 'permafrost':\n                    decay_probability = 1 - (1 - 5.5E-6)**(len(oligo)*self.years)\n                elif self.storage_conditions == 'biogene':\n                    decay_probability = 1 - (1 - 1E-7)**(len(oligo)*self.years)\n\n                else: \n                    decay_probability = 1 - (1 - 5E-3)**(len(oligo)*self.years)\n\n                rndm = random.random()\n\n                if rndm &gt; decay_probability:\n                    remaining_oligos.append(oligo)\n                else:\n                    counter += 1\n\n                strand_breaks = counter\n                # Approach, where every oligo has an equal probability of decay\n                # N_t = len(data) * math.exp(-decay_probability * self.years)\n                # remaining_oligos = random.sample(data, int(round(N_t)))\n\n            stored_data = StoredData(assembled_data=remaining_oligos)\n\n        else: \n            raise ValueError(\"The input data is not an instance of StoredData.\")\n\n    info = {}\n    info['number_of_strand_breaks'] = strand_breaks\n\n    return stored_data, info\n</code></pre>"},{"location":"reference/#dnabyte.sequencing.SimulateSequencing","title":"<code>SimulateSequencing</code>","text":"<p>Simulate sequencing of DNA sequences. There are two main types of sequencing technologies: Illumina and Nanopore, each with their  characteristic error profiles.</p> <p>:param sequencing_technology: A string 'illumina', or 'nanopore'. None to perform no sequencing simulation.</p> Source code in <code>dnabyte/sequencing.py</code> <pre><code>class SimulateSequencing:\n    \"\"\"\n    Simulate sequencing of DNA sequences.\n    There are two main types of sequencing technologies: Illumina and Nanopore, each with their \n    characteristic error profiles.\n\n    :param sequencing_technology: A string 'illumina', or 'nanopore'. None to perform no sequencing simulation.\n    \"\"\"\n\n    def __init__(self, params, logger=None):\n        self.sequencing_method = params.sequencing_method\n        if self.sequencing_method == 'iid':\n            self.iidmethod = params.iid_error_rate\n        else:\n            self.iidmethod = None\n\n    def simulate(self, data):\n        \"\"\"\n        Simulate sequencing of DNA sequences.\n\n        :param data: A list of DNA sequences.\n        :return: A list of sequenced DNA sequences.\n        \"\"\"\n        if self.sequencing_method == None:\n            sequenced_data = SequencedData(data=data.data)\n            error_dict = {}\n\n        else:\n            if isinstance(data, StoredData):\n\n                # # Simulate sequencing errors\n                # if self.sequencing_technology == 'illumina':\n                #     sequenced_data = [self.simulate_illumina_sequencing(seq) for seq in data]\n                # elif self.sequencing_technology == 'nanopore':\n                #     sequenced_data = [self.simulate_nanopore_sequencing(seq) for seq in data]\n                # else:\n                #     raise ValueError(\"Sequencing technology not recognized.\")\n\n                data_seq, error_dict = sequencing_simulation(data.data, method_id=self.sequencing_method, errorrate=self.iidmethod)\n\n                sequenced_data = SequencedData(data=data_seq)\n            else:\n                raise ValueError(\"The input data is not an instance of StoredData.\")\n        info = {}\n        info['eror_dict'] = error_dict\n\n        return sequenced_data, info\n</code></pre>"},{"location":"reference/#dnabyte.sequencing.SimulateSequencing.simulate","title":"<code>simulate(data)</code>","text":"<p>Simulate sequencing of DNA sequences.</p> <p>:param data: A list of DNA sequences. :return: A list of sequenced DNA sequences.</p> Source code in <code>dnabyte/sequencing.py</code> <pre><code>def simulate(self, data):\n    \"\"\"\n    Simulate sequencing of DNA sequences.\n\n    :param data: A list of DNA sequences.\n    :return: A list of sequenced DNA sequences.\n    \"\"\"\n    if self.sequencing_method == None:\n        sequenced_data = SequencedData(data=data.data)\n        error_dict = {}\n\n    else:\n        if isinstance(data, StoredData):\n\n            # # Simulate sequencing errors\n            # if self.sequencing_technology == 'illumina':\n            #     sequenced_data = [self.simulate_illumina_sequencing(seq) for seq in data]\n            # elif self.sequencing_technology == 'nanopore':\n            #     sequenced_data = [self.simulate_nanopore_sequencing(seq) for seq in data]\n            # else:\n            #     raise ValueError(\"Sequencing technology not recognized.\")\n\n            data_seq, error_dict = sequencing_simulation(data.data, method_id=self.sequencing_method, errorrate=self.iidmethod)\n\n            sequenced_data = SequencedData(data=data_seq)\n        else:\n            raise ValueError(\"The input data is not an instance of StoredData.\")\n    info = {}\n    info['eror_dict'] = error_dict\n\n    return sequenced_data, info\n</code></pre>"},{"location":"simulation/","title":"Simulation Framework","text":"<p>The <code>Simulation</code> class orchestrates the full end-to-end process of DNA-based data storage simulation in DNAbyte. It simulates encoding, synthesis, storage, sequencing, error correction, and decoding of digital files using oligonucleotide sequences.</p>"},{"location":"simulation/#overview","title":"Overview","text":"<p>The simulation pipeline consists of the following steps:</p> <ol> <li>Binarize input data into a compressed bitstream</li> <li>Encode the bitstream into oligonucleotide codewords</li> <li>Simulate synthesis errors</li> <li>Simulate storage degradation</li> <li>Simulate sequencing</li> <li>Perform error correction</li> <li>Decode data</li> <li>Compare with original</li> <li>Restore output files</li> </ol>"},{"location":"simulation/#class-definition","title":"Class Definition","text":"<pre><code>class Simulation():\n    def __init__(self, simulation_parameters, debug=False):\n        ...\n</code></pre>"},{"location":"simulation/#initialization","title":"Initialization","text":"<ul> <li>A <code>Params</code> object defines the settings for each simulation.</li> <li>A logger records each step in a timestamped file.</li> <li>A unique job identifier (<code>self.job_identifier</code>) is assigned to each simulation run.</li> </ul>"},{"location":"simulation/#method-run","title":"Method: run()","text":"<pre><code>def run(self, paralel=False):\n    ...\n</code></pre> <p>This method executes the entire simulation. Currently, parallel processing is not implemented but planned.</p>"},{"location":"simulation/#key-simulation-steps","title":"Key Simulation Steps","text":""},{"location":"simulation/#step-1-binarize-data","title":"Step 1: Binarize Data","text":"<pre><code>data_obj = DNADS([params.filename])\ndata_raw = RawData(data_obj)\n</code></pre> <p>Input files are compressed and transformed into a binary stream.</p>"},{"location":"simulation/#step-2-encode-data","title":"Step 2: Encode Data","text":"<pre><code>enc = Encode(params, logger=self.simlogger)\ndata_enc, info = enc.encode(data_raw)\n</code></pre> <p>Encoding schemes and barcoding are applied to generate codewords.</p>"},{"location":"simulation/#step-3-simulate-synthesis","title":"Step 3: Simulate Synthesis","text":"<pre><code>syn = SimulateAssembly(params, logger=self.simlogger)\ndata_syn, info = syn.simulate(data_enc)\n</code></pre> <p>Simulates oligo synthesis errors such as dropout and substitutions.</p>"},{"location":"simulation/#step-4-simulate-storage","title":"Step 4: Simulate Storage","text":"<pre><code>sto = SimulateStorage(params, logger=self.simlogger)\ndata_sto, info = sto.simulate(data_syn)\n</code></pre> <p>Models degradation over time such as strand breaks.</p>"},{"location":"simulation/#step-5-simulate-sequencing","title":"Step 5: Simulate Sequencing","text":"<pre><code>seq = SimulateSequencing(params, logger=self.simlogger)\ndata_seq, info = seq.simulate(data_sto)\ndata_seq = SequencedData(data_seq.data)\n</code></pre> <p>Sequencing errors are simulated on degraded oligos.</p>"},{"location":"simulation/#step-6-process-data","title":"Step 6: Process Data","text":"<pre><code>data_cor, info = enc.process(data_seq)\n</code></pre> <p>Applies decoding-preprocessing and error correction.</p>"},{"location":"simulation/#step-7-decode-data","title":"Step 7: Decode Data","text":"<pre><code>data_dec, valid, info = enc.decode(data_cor)\n</code></pre> <p>Attempts to recover the original bitstream.</p>"},{"location":"simulation/#step-8-compare-results","title":"Step 8: Compare Results","text":"<pre><code>comparison, res = compare(data_dec, data_raw, logger=self.simlogger)\n</code></pre> <p>Checks if the decoded output matches the original data.</p>"},{"location":"simulation/#step-9-restore-file","title":"Step 9: Restore File","text":"<pre><code>RestoredData(data_dec, output_folder='./simulations/simfiles/', job_identifier=self.job_identifier)\n</code></pre> <p>Generates the output file from decoded data.</p>"},{"location":"simulation/#logging","title":"Logging","text":"<p>Each simulation logs its steps to:</p> <pre><code>simulations/simlogs/job_&lt;timestamp&gt;.log\n</code></pre> <p>Results are also saved as:</p> <pre><code>simulations/simlogs/res_&lt;timestamp&gt;.pickle\n</code></pre>"},{"location":"simulation/#output","title":"Output","text":"<p>A dictionary <code>results</code> is returned and contains:</p> <ul> <li>Step-wise performance info</li> <li>Final simulation status</li> <li>Duration, error counts, and decoding validation</li> </ul>"},{"location":"simulation/#planned-features","title":"Planned Features","text":"<ul> <li>Parallel processing support</li> <li>More complex storage/sequencing models</li> <li>CLI integration</li> </ul>"},{"location":"simulation/#usage-example","title":"Usage Example","text":"<pre><code>from dnabyte.simulation import Simulation\nsim = Simulation([params1, params2])\nresults = sim.run()\n</code></pre>"},{"location":"simulation/#contact","title":"Contact","text":"<p>For questions, issues, or contributions, open a GitHub issue or contact the maintainers.</p>"},{"location":"usage/","title":"Pipeline Steps","text":""},{"location":"usage/#step-0-parameter-configuration-params-class","title":"Step 0: Parameter Configuration (<code>Params</code> class)","text":"<p>The <code>Params</code> class encapsulates all configuration parameters required to simulate a full DNA data storage workflow. The parameters can be grouped into the steps of the pipeline they concern:</p>"},{"location":"usage/#parameter-groups","title":"Parameter Groups","text":"<ul> <li>File &amp; Identification: <code>name</code>, <code>seed</code>, <code>debug</code></li> <li>Encoding: <code>encoding_scheme</code>, <code>assembly_structure</code>, <code>library_name</code>, <code>codeword_length</code>, <code>sigma_amount</code>, <code>percent_of_symbols</code></li> <li>Error Correction: <code>inner_error_correction</code>, <code>outer_error_correction</code>, <code>reed_solo_percentage</code>, <code>ltcode_header</code>, <code>index_carry_length</code></li> <li>Synthesis: <code>synthesis_method</code>, <code>mean</code>, <code>vol</code>, <code>std_dev</code>, <code>hybridisation_steps</code></li> <li>Storage: <code>years</code>, <code>storage_conditions</code></li> <li>Sequencing: <code>sequencing_method</code>, <code>iid_error_rate</code></li> </ul> <p>More details about the parameters will be provided in the respective sections. </p>"},{"location":"usage/#example-usage","title":"Example Usage","text":"<pre><code>from dnabyte.params import Params\n\nparams = Params(\n    name=\"test1\",\n    encoding_scheme=\"linear_encoding\",\n    assembly_structure=\"linear_assembly\",\n    outer_error_correction=\"reedsolomon\",\n    reed_solo_percentage=10,\n    dna_barcode_length=6,\n    codeword_length=100,\n    library_name=\"standard_library.txt\"\n)\n</code></pre>"},{"location":"usage/#step-1-binarize-and-compress-data","title":"Step 1: Binarize and Compress Data","text":"<p>To initiate the binarization process, instantiate a <code>DNADS</code> object with a list of file paths. Then use this object to create a <code>RawData</code> object.</p> <pre><code>from dnabyte.data import DNADS, RawData\n\ndata_obj = DNADS([\"mi_dna_disc_logo.png\"])\ndata_raw = RawData(data_obj)\n</code></pre> <p>The <code>RawData</code> class compresses all input files into a temporary <code>.tar.gz</code> archive, reads it as a binary stream, and converts it into a bitstring. This binary string is stored in <code>data_raw.data</code>, with its length available via <code>data_raw.length</code>. The temporary archive is deleted after use. The <code>RawData</code> class is a subclass of <code>DNADS</code>. It represents the compressed binary form of one or more input files. It is used to initiate the encoding process.</p>"},{"location":"usage/#alternative-instantiation-from-bitstream","title":"Alternative Instantiation from Bitstream","text":"<p>For testing purposes, a <code>RawData</code> object can also be created from a binary string:</p> <pre><code>raw_data = RawData.from_bitstream('100001010101')\n</code></pre> <p>This method is especially useful in simulations or unit tests where reading actual files is not required.</p>"},{"location":"usage/#step-2-encode-data","title":"Step 2: Encode Data","text":"<p>The process of encoding raw data involves two key steps:</p> <ul> <li> <p>Instantiate an <code>Encode</code> Object by providing all the required parameters, stored in the 'Params'.</p> </li> <li> <p>Apply the 'encode' Method: Use the encode method on a RawData object to transform the raw binary data into DNA sequences. This method applies the specified encoding strategy and optionally incorporates error correction mechanisms.</p> </li> </ul> <p>This two-step approach is a consistent design pattern used throughout the framework when transitioning between different data classes.</p>"},{"location":"usage/#usage","title":"Usage","text":"<pre><code>from dnabyte.encode import Encode\n\nenc = Encode(params=params, logger=self.simlogger)\ndata_enc, info = enc.encode(data_raw)\n</code></pre>"},{"location":"usage/#encoding-parameters","title":"Encoding Parameters","text":"Assembly Structure Encoding Scheme Encoder Used <code>linear_assembly</code> <code>linear_encoding</code> <code>EncodeLinearChain</code> <code>linear_assembly</code> <code>binomial_encoding</code> <code>EncodeLinearBinom</code> <code>positional_assembly</code> <code>linear_encoding</code> <code>EncodePolyChain</code> <code>positional_assembly</code> <code>binomial_encoding</code> <code>EncodePolyBinom</code> <code>synthesis</code> <code>max_density_encoding</code> <code>EncodeMaxDensity</code> <code>synthesis</code> <code>no_homopolymeroddeven_encoding</code> <code>EncodeNoHomoPolyOddEven</code>"},{"location":"usage/#error-correction-parameters","title":"Error Correction Parameters","text":"Parameter Description <code>inner_error_correction</code> Selects inner-layer error correction (e.g., <code>ltcode</code>, <code>None</code>) <code>ltcode_header</code> Number of bits used for Luby Transform code headers <code>percent_of_symbols</code> Percentage of symbols included in each encoded LT packet <code>index_carry_length</code> Number of bits used to carry the LT-code packet index <code>outer_error_correction</code> Selects outer-layer error correction (e.g., <code>reedsolomon</code>, <code>None</code>) <code>reed_solo_percentage</code> Redundancy percentage for Reed-Solomon coding <p>These error correction methods are commonly used for synthesis-based methods, where the information lies in the sequence of nucleotides. They can, however, also be used for assembly based methods, where the information lies in the sequence of motives (short nucleotide sequences). Bare in mind, that assembly-based methods exhibit an implicit error correction that results from the fact that it lies in a restricted sequence space and that in most cases error correction is not required.  </p>"},{"location":"usage/#returns","title":"Returns","text":"<ul> <li>An <code>EncodedData</code> object containing the encoded oligonucleotide sequences.</li> <li>An <code>info</code> dictionary with encoding metrics and metadata.</li> </ul>"},{"location":"usage/#step-3-simulate-synthesis","title":"Step 3: Simulate Synthesis","text":"<p>Class Involved: <code>SimulateAssembly</code></p> <p>Simulates the synthesis process of converting digital data into DNA oligonucleotides. Essentially, there are two different snythesis strategies that can be applied, which are determined by the parameter 'assembly_structure'. The option <code>synthesis</code> describes the nucleotide-wise chemical synthesis, which is based on the methods from Schwarz et al. The options <code>linear_assembly</code> or <code>positional_assembly</code> describe the synthesis by ligating short oligos from a so called library. This approach is based on a simulation of the hybridisation and ligation of the molecules. </p>"},{"location":"usage/#usage_1","title":"Usage","text":"<pre><code>from dnabyte.assembly import SimulateAssembly\n\nsyn = SimulateAssembly(params, logger=self.simlogger)\ndata_syn, info = syn.simulate(data_enc)\n</code></pre>"},{"location":"usage/#synthesis-parameters","title":"Synthesis Parameters","text":"Synthesis Approach Method Method ID Column synthesized oligos MutS <code>68</code> Consensus shuffle <code>69</code> ErrASE <code>6</code> No error correction <code>71</code> Microarray based oligo pools Oligo hybridization based error correction <code>4</code> High-temperature ligation/hybridization based <code>5</code> ErrASE <code>3</code> Nuclease-based <code>7</code> NGS-based <code>70</code> No error correction <code>71</code> <p>For assembly based approaches only the following parameters must be given:</p> Parameter Description <code>mean</code> the mean number of copies of an oligo <code>std_dev</code> the standard deviation of copies of an oligo <code>vol</code> the volume of the solution <code>hybridisation</code> the number of random hybridisation steps (proxy for reaction time)"},{"location":"usage/#reference","title":"Reference","text":"<p>[1] Schwarz, Michael, et al. \"MESA: automated assessment of synthetic DNA fragments and simulation of DNA synthesis, storage, sequencing and PCR errors.\" Bioinformatics 36.11 (2020): 3322-3326.</p>"},{"location":"usage/#step-4-simulate-storage","title":"Step 4: Simulate Storage","text":"<p>The <code>SimulateStorage</code> class models the long-term degradation of DNA sequences stored under various environmental conditions. DNA degradation is modeled probabilistically based on empirical decay rates under three conditions:</p> <ul> <li>Room temperature: approximated half-life of 521 years (decay rate \u2248 0.00133)</li> <li>Permafrost: 5.5\u00d710\u207b\u2076 per nucleotide per year Source: Allentoft et al., 2012</li> <li>Biogene capsule: 1\u00d710\u207b\u2077 per nucleotide per year Source: Coudy et al., 2021</li> </ul>"},{"location":"usage/#usage_2","title":"Usage","text":"<pre><code>from dnabyte.storage import SimulateStorage\n\nsto = SimulateStorage(params, logger=self.simlogger)\ndata_sto, info = sto.simulate(data_syn)\n</code></pre>"},{"location":"usage/#storage-parameters","title":"Storage Parameters","text":"Parameter Type Description <code>years</code> <code>int</code> Number of years to simulate storage. Use <code>0</code> to disable simulation. <code>storage_conditions</code> <code>str</code> One of <code>'permafrost'</code>, <code>'room_temperature'</code>, <code>'biogene'</code>, or <code>'random'</code>. <p>The synthetic <code>'random'</code> mode allows base substitutions to simulate artificial mutation rates.</p>"},{"location":"usage/#return-values","title":"Return Values","text":"<ul> <li><code>StoredData</code> object (filtered or mutated sequences)</li> <li><code>info</code> dictionary containing:</li> <li><code>number_of_strand_breaks</code>: the number of sequences simulated to be degraded</li> </ul>"},{"location":"usage/#references","title":"References","text":"<p>[1] Allentoft, M. E. et al. The half-life of DNA in bone: measuring decay kinetics in 158 dated fossils. Proc. R. Soc. B 279, 4724\u20134733 (2012). [2] Coudy, D. et al. Long term conservation of DNA at ambient temperature: Implications for DNA data storage. PLoS One 16.11 (2021): e0259868.</p>"},{"location":"usage/#step-5-simulate-sequencing","title":"Step 5: Simulate Sequencing","text":"<p>The <code>SimulateSequencing</code> class models the sequencing process by applying sequencing-specific error profiles to stored DNA oligonucleotides. This step reflects how technologies like Illumina or Nanopore introduce errors into DNA reads.</p>"},{"location":"usage/#usage_3","title":"Usage","text":"<pre><code>from dnabyte.sequencing import SimulateSequencing\n\nsimulator = SimulateSequencing(params)\nsequenced_data, info = simulator.simulate(stored_data)\n</code></pre>"},{"location":"usage/#supported-modes","title":"Supported Modes","text":"Sequencing Method Description <code>None</code> No sequencing simulation is performed. <code>'iid'</code> Applies an independent and identically distributed error model (custom rate). <code>35</code> Illumina: Single End <code>36</code> Illumina: Paired End <code>39</code> Nanopore: 1D <code>40</code> Nanopore: 2D <code>37</code> PacBio: Subread <code>38</code> PacBio: CCS"}]}